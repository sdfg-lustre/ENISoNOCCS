node Harness (In_P: UsrInt) returns (noError :bool)

var

e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e13, e14, e15, e16, e18, e19, e20, e17, e21, e22, e23, e24, e25, e26, e27, e28, e29, In, P1nbrFired, W1nbrFired, P2nbrFired, W2nbrFired, T1nbrFired, T2nbrFired, R1nbrFired, R2nbrFired, CnbrFired, C2nbrFired, puit1nbrFired, puit2nbrFired, puit3nbrFired, puit4nbrFired:UsrInt;


positiveValues, v1, v2, v3, v4, v5: bool;

let

(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e13, e14, e15, e16, e18, e19, e20, e17, e21, e22, e23, e24, e25, e26, e27, e28, e29, In, P1nbrFired, W1nbrFired, P2nbrFired, W2nbrFired, T1nbrFired, T2nbrFired, R1nbrFired, R2nbrFired, CnbrFired, C2nbrFired, puit1nbrFired, puit2nbrFired, puit3nbrFired, puit4nbrFired) = top(In_P);

positiveValues = UsrIntGte( e1, UsrInt_0) 
	and UsrIntGte( e2, UsrInt_0) 
	and UsrIntGte( e3, UsrInt_0) 
	and UsrIntGte( e4, UsrInt_0) 
	and UsrIntGte( e5, UsrInt_0) 
	and UsrIntGte( e6, UsrInt_0) 
	and UsrIntGte( e7, UsrInt_0) 
	and UsrIntGte( e8, UsrInt_0) 
	and UsrIntGte( e9, UsrInt_0) 
	and UsrIntGte( e10, UsrInt_0) 
	and UsrIntGte( e11, UsrInt_0) 
	and UsrIntGte( e13, UsrInt_0) 
	and UsrIntGte( e14, UsrInt_0) 
	and UsrIntGte( e15, UsrInt_0) 
	and UsrIntGte( e16, UsrInt_0) 
	and UsrIntGte( e18, UsrInt_0) 
	and UsrIntGte( e19, UsrInt_0) 
	and UsrIntGte( e20, UsrInt_0) 
	and UsrIntGte( e17, UsrInt_0) 
	and UsrIntGte( e21, UsrInt_0) 
	and UsrIntGte( e22, UsrInt_0) 
	and UsrIntGte( e23, UsrInt_0) 
	and UsrIntGte( e24, UsrInt_0) 
	and UsrIntGte( e25, UsrInt_0) 
	and UsrIntGte( e26, UsrInt_0) 
	and UsrIntGte( e27, UsrInt_0) 
	and UsrIntGte( e28, UsrInt_0) 
	and UsrIntGte( e29, UsrInt_0) 
	and UsrIntGte( In, UsrInt_0) 
	and UsrIntGte( P1nbrFired , UsrInt_0) 
	and UsrIntGte( W1nbrFired , UsrInt_0) 
	and UsrIntGte( P2nbrFired , UsrInt_0) 
	and UsrIntGte( W2nbrFired , UsrInt_0) 
	and UsrIntGte( T1nbrFired , UsrInt_0) 
	and UsrIntGte( T2nbrFired , UsrInt_0) 
	and UsrIntGte( R1nbrFired , UsrInt_0) 
	and UsrIntGte( R2nbrFired , UsrInt_0) 
	and UsrIntGte( CnbrFired , UsrInt_0) 
	and UsrIntGte( C2nbrFired , UsrInt_0) 
	and UsrIntGte( puit1nbrFired , UsrInt_0) 
	and UsrIntGte( puit2nbrFired , UsrInt_0) 
	and UsrIntGte( puit3nbrFired , UsrInt_0) 
	and UsrIntGte( puit4nbrFired , UsrInt_0) ;

--ok: possible to have up to (n+1) W1 performed for  n R1 
v1= UsrIntLte(e26,  UsrInt_2) and UsrIntLte(e27,  UsrInt_1) and UsrIntLte( e27,  e26);
--ok:  R2 fires after  R1 and between two R1 there is one and only one  R2 
v2=  (UsrIntEq( e28, e29) or  UsrIntEq(e28, UsrIntPlus (e29, UsrInt_1))) and ( (UsrIntEq( pre e29, UsrInt_0) and UsrIntEq( e29, UsrInt_1))=>UsrIntEq( pre e28, UsrInt_1) ) ;

--(duree min entre la fin de R2 and la  fin de R1 )
--ok: le premier v3  doit être  vrai le deuxième contenat un pre de plus doit être faux
v3= true ->(UsrIntEq( pre   e29 , UsrInt_0)  and UsrIntEq( e29 , UsrInt_1)) => UsrIntEq (pre pre  pre pre pre   e28 , UsrInt_1);
--  v3= true ->(UsrIntEq( pre   e29 , UsrInt_0)  and UsrIntEq( e29 , UsrInt_1))=>UsrIntEq (pre pre  pre pre pre  pre   e28 , UsrInt_1);

--(duree max entre la fin de R2 and la fin de R1)
--ok: le premier v4  doit être  vrai le deuxième contenant un pre de moins doit être faux
v4= true ->(UsrIntEq( pre   e29 , UsrInt_0)  and UsrIntEq( e29 , UsrInt_1)) => UsrIntEq(   pre pre pre  pre pre pre pre pre pre  e28 , UsrInt_0);
--v4= true ->(UsrIntEq( pre   e29 , UsrInt_0)  and UsrIntEq( e29 , UsrInt_1)) => UsrIntEq(   pre pre pre  pre pre pre pre pre  e28 , UsrInt_0);
 

--le producteur P1 peut etre en  avance au maximum de trois occurances par rapport au consomateur C
v5= UsrIntLte( UsrIntMinus ( e21, e22) , UsrInt_3);--true for x
--v5= UsrIntLte( UsrIntMinus ( e21, e22) , UsrInt_2);--false  for x-1

noError=  v5;
assert UsrIntLte(In_P, UsrInt_1) and UsrIntGte(In_P, UsrInt_0) ;
tel
