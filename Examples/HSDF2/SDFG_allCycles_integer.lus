--** This lustre code is generated automatically on 20 aoÃ»t 2020 08:56:12 AM
--**It corresponds to a translation to Lustre of the  SDFG model  of the design "hdfs" 



--**************** Const Rates ****************--

const a__in_rate_in = 1;
const a__e1in_rate_in = 1;
const a__e1out_rate_out = 1;
const a__e5x_rate_out = 3;
const b__e5x_rate_in = 1;
const b__e16in_rate_in = 1;
const b__e16out_rate_out = 1;
const b__e17x_rate_out = 1;
const c__e17x_rate_in = 1;
const c__e18x_rate_out = 1;
const d__e18x_rate_in = 3;
const d__e19in_rate_in = 1;
const d__e19out_rate_out = 1;

--**************** Init Channel ****************--

const e1x_I = 1 ;
const e5x_I = 0 ;
const e16x_I = 1 ;
const e17x_I = 0 ;
const e18x_I = 0 ;
const e19x_I = 1 ;

const in_I = 0 ;

--**************** Actors Translation ****************--

node a_(in, e1in :int) returns (in_C, e1in_C, e1out_P, e5x_P :int; a_nbrFired, nbrRuns : int );

var
a_nbrEnd: int;
let
a_nbrFired= if a_DoFire(in, e1in,3) then 3
		else if a_DoFire(in, e1in,2) then 2
		else if a_DoFire(in, e1in,1) then 1
		else 0;

a_nbrEnd= 0 -> pre (a_nbrFired);



nbrRuns=  (a_nbrFired - a_nbrEnd ) ->(pre nbrRuns) +a_nbrFired - a_nbrEnd ;

(in_C, e1in_C) = ((a_nbrFired * a__in_rate_in), (a_nbrFired * a__e1in_rate_in));

(e1out_P, e5x_P) = ((a_nbrEnd * a__e1out_rate_out), (a_nbrEnd * a__e5x_rate_out));

tel;
------------------
node a_DoFire(in, e1in :int; times: int) returns ( yes: bool);
let

yes = if  (in>=  (times * a__in_rate_in)) 
	and  (e1in>=  (times * a__e1in_rate_in)) 
	then true 
	else false;

tel;
------------------
node b_(e5x, e16in :int) returns (e5x_C, e16in_C, e16out_P, e17x_P :int; b_nbrFired, nbrRuns : int );

var
b_nbrEnd: int;
let
b_nbrFired= if b_DoFire(e5x, e16in,3) then 3
		else if b_DoFire(e5x, e16in,2) then 2
		else if b_DoFire(e5x, e16in,1) then 1
		else 0;

b_nbrEnd= 0 -> pre (b_nbrFired);



nbrRuns=  (b_nbrFired - b_nbrEnd ) ->(pre nbrRuns) +b_nbrFired - b_nbrEnd ;

(e5x_C, e16in_C) = ((b_nbrFired * b__e5x_rate_in), (b_nbrFired * b__e16in_rate_in));

(e16out_P, e17x_P) = ((b_nbrEnd * b__e16out_rate_out), (b_nbrEnd * b__e17x_rate_out));

tel;
------------------
node b_DoFire(e5x, e16in :int; times: int) returns ( yes: bool);
let

yes = if  (e5x>=  (times * b__e5x_rate_in)) 
	and  (e16in>=  (times * b__e16in_rate_in)) 
	then true 
	else false;

tel;
------------------
node c_(e17x :int) returns (e17x_C, e18x_P :int; c_nbrFired, nbrRuns : int );

var
c_nbrEnd: int;
let
c_nbrFired= if c_DoFire(e17x,3) then 3
		else if c_DoFire(e17x,2) then 2
		else if c_DoFire(e17x,1) then 1
		else 0;

c_nbrEnd= 0 -> pre (c_nbrFired);



nbrRuns=  (c_nbrFired - c_nbrEnd ) ->(pre nbrRuns) +c_nbrFired - c_nbrEnd ;

(e17x_C) = ((c_nbrFired * c__e17x_rate_in));

(e18x_P) = ((c_nbrEnd * c__e18x_rate_out));

tel;
------------------
node c_DoFire(e17x :int; times: int) returns ( yes: bool);
let

yes = if  (e17x>=  (times * c__e17x_rate_in)) 
	then true 
	else false;

tel;
------------------
node d_(e18x, e19in :int) returns (e18x_C, e19in_C, e19out_P :int; d_nbrFired, nbrRuns : int );

var
d_nbrEnd: int;
let
d_nbrFired= if d_DoFire(e18x, e19in,3) then 3
		else if d_DoFire(e18x, e19in,2) then 2
		else if d_DoFire(e18x, e19in,1) then 1
		else 0;

d_nbrEnd= 0 -> pre (d_nbrFired);



nbrRuns=  (d_nbrFired - d_nbrEnd ) ->(pre nbrRuns) +d_nbrFired - d_nbrEnd ;

(e18x_C, e19in_C) = ((d_nbrFired * d__e18x_rate_in), (d_nbrFired * d__e19in_rate_in));

(e19out_P) = ((d_nbrEnd * d__e19out_rate_out));

tel;
------------------
node d_DoFire(e18x, e19in :int; times: int) returns ( yes: bool);
let

yes = if  (e18x>=  (times * d__e18x_rate_in)) 
	and  (e19in>=  (times * d__e19in_rate_in)) 
	then true 
	else false;

tel;
------------------
node top (in_P: int) returns (e1x, e5x, e16x, e17x, e18x, e19x, in, a_nbrFired, b_nbrFired, c_nbrFired, d_nbrFired: int);

-------------- Les variables -------------- 

var

e1x_C, e1x_P: int; 
e5x_C, e5x_P: int; 
e16x_C, e16x_P: int; 
e17x_C, e17x_P: int; 
e18x_C, e18x_P: int; 
e19x_C, e19x_P: int; 
in_C : int;
a_nbrRuns, b_nbrRuns, c_nbrRuns, d_nbrRuns : int; 

positiveValues: bool;


let

assert in_P  >=0; 
 
e1x = e1x_I -> pre  (   e1x-e1x_C)+ e1x_P;
e5x = e5x_I -> pre  (   e5x-e5x_C)+ e5x_P;
e16x = e16x_I -> pre  (   e16x-e16x_C)+ e16x_P;
e17x = e17x_I -> pre  (   e17x-e17x_C)+ e17x_P;
e18x = e18x_I -> pre  (   e18x-e18x_C)+ e18x_P;
e19x = e19x_I -> pre  (   e19x-e19x_C)+ e19x_P;

in = in_P -> pre  ( in-in_C)+ in_P ;


(in_C, e1x_C, e1x_P, e5x_P, a_nbrFired, a_nbrRuns  ) = a_(in, e1x);
(e5x_C, e16x_C, e16x_P, e17x_P, b_nbrFired, b_nbrRuns  ) = b_(e5x, e16x);
(e17x_C, e18x_P, c_nbrFired, c_nbrRuns  ) = c_(e17x);
(e18x_C, e19x_C, e19x_P, d_nbrFired, d_nbrRuns  ) = d_(e18x, e19x);


positiveValues = ( e1x>=   0) 
	and  ( e5x>=   0) 
	and  ( e16x>=   0) 
	and  ( e17x>=   0) 
	and  ( e18x>=   0) 
	and  ( e19x>=   0) 
	and  ( in>=  0) 
	and  ( a_nbrFired >= 0) 
	and  ( b_nbrFired >= 0) 
	and  ( c_nbrFired >= 0) 
	and  ( d_nbrFired >= 0) ;

--%MAIN;

--%PROPERTY  "Ok, all variables are positive "  positiveValues;


tel;

