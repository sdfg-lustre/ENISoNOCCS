--** This lustre code is generated automatically on 16 juin 2020 08:25:16 AM
--** It corresponds to the translation of an SDFG model (example)  to Lustre. This version produce a Lustre code having a reduced number of steps.




--**************** Const Rates ****************--

const a_e1in_rate_in = 1;
const a_e1out_rate_out = 1;
const a_e2_rate_out = 1;
const b_e2_rate_in = 1;
const b_e4_rate_in = 2;
const b_e3_rate_out = 2;
const c_e3_rate_in = 3;
const c_e4_rate_out = 3;

--****************  Actors' durations ****************--

const a_maxStages  = 2;
const a_duration  = 2;
const b_maxStages  = 1;
const b_duration  = 1;
const c_maxStages  = 1;
const c_duration  = 1;
const  maxDuration  = 2;

--**************** Init Channel ****************--

const e2_I = 1;
const e3_I = 3;
const e4_I = 1;
const e1_I = 1;


--************************************************--
--******* Translation of Actor: a***************--
--************************************************--
node a(clock, e1in :int) returns (nextClock, e1in_C, e1out_P, e2_P :int; anbrFired: int );

var
anbrEnd: int;
stage :int;
 lastStage  :int;
rTime1, nbrEnd1 : int; 
rTime2, nbrEnd2 : int; 
let
anbrFired= if aDoFire(e1in,1) then 1
		else 0;

(e1in_C) = ((anbrFired * a_e1in_rate_in));

stage = (if (anbrFired = 0) then 0 
         else   1) 
 -> if (anbrFired = 0) then 0 
         else if (pre lastStage = a_maxStages) then  1 
         else  (pre lastStage + 1) ; 
 
lastStage = (if (anbrFired = 0) then 0 
         else   1) 
 -> if (anbrFired = 0) then (pre lastStage) 
         else stage; 
 

(e1out_P, e2_P) = ((anbrEnd * a_e1out_rate_out), (anbrEnd * a_e2_rate_out));

tel;
------------------subnode Dofire of Actora-----------------
node aDoFire(e1in,times:int) returns ( yes: bool);
let

yes = if (e1in>=  (times * a_e1in_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of Actora-----------------
node aStage(clock,  stage, numStage, e1out_PD, e2_PD: int) returns (rTime, e1out_P, e2_P : int);

var 
e1out_PDBuffer, e2_PDBuffer: int; 
selected, endExecution, running : bool; 

 let 
selected = if  (stage = numStage) then true else false ; 
 endExecution= false -> if not pre (running)  then false else pre  ((rTime - clock) = 0); 
running = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre running; 
rTime = if  selected then a_duration  else maxDuration -> 
          if  selected then a_duration 
          else if  (pre running) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 
(e1out_PDBuffer, e2_PDBuffer) = if selected then (e1out_PD, e2_PD) 
                               else (0, 0) 
 ->if selected then (e1out_PD, e2_PD) 
                               else if endExecution then (0, 0)
           else pre (e1out_PDBuffer, e2_PDBuffer); 
(e1out_P, e2_P) = (0, 0) ->   if endExecution then pre (e1out_PDBuffer, e2_PDBuffer)
                                        else (0, 0); 
tel; 


--************************************************--
--******* Translation of Actor: b***************--
--************************************************--
node b(clock, e2, e4 :int) returns (nextClock, e2_C, e4_C, e3_P :int; bnbrFired: int );

var
bnbrEnd: int;
let
bnbrFired= if bDoFire(e2, e4,2) then 2
		else if bDoFire(e2, e4,1) then 1
		else 0;

(e2_C, e4_C) = ((bnbrFired * b_e2_rate_in), (bnbrFired * b_e4_rate_in));

bnbrEnd = 0 -> pre bnbrFired  ;
(e3_P) = ((bnbrEnd * b_e3_rate_out));

nextClock = if (bnbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorb-----------------
node bDoFire(e2, e4,times:int) returns ( yes: bool);
let

yes = if (e2>=  (times * b_e2_rate_in)) 
	and (e4>=  (times * b_e4_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: c***************--
--************************************************--
node c(clock, e3 :int) returns (nextClock, e3_C, e4_P :int; cnbrFired: int );

var
cnbrEnd: int;
let
cnbrFired= if cDoFire(e3,2) then 2
		else if cDoFire(e3,1) then 1
		else 0;

(e3_C) = ((cnbrFired * c_e3_rate_in));

cnbrEnd = 0 -> pre cnbrFired  ;
(e4_P) = ((cnbrEnd * c_e4_rate_out));

nextClock = if (cnbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorc-----------------
node cDoFire(e3,times:int) returns ( yes: bool);
let

yes = if (e3>=  (times * c_e3_rate_in)) 
	then true 
	else false;

tel;
--******* Node Min***************--
node Min (x, y :int) returns ( r: int);
let
r= if  (x < y) then x else y;
tel;

--************************************************--
--******* Node Top***************--
--************************************************--
node top (_: bool) returns ( clock, e2, e3, e4, e1, anbrFired, bnbrFired, cnbrFired:int);

var

e2_C, e2_P: int; 
e3_C, e3_P: int; 
e4_C, e4_P: int; 
e1_C, e1_P: int; 
anextClock : int;  
bnextClock : int;  
cnextClock : int;  
positiveValues: bool; 

let

e2 = e2_I ->  ( pre ( e2 - e2_C) + e2_P);
e3 = e3_I ->  ( pre ( e3 - e3_C) + e3_P);
e4 = e4_I ->  ( pre ( e4 - e4_C) + e4_P);
e1 = e1_I ->  ( pre ( e1 - e1_C) + e1_P);




(anextClock, e1_C, e1_P, e2_P, anbrFired) = a(clock, e1);
(bnextClock, e2_C, e4_C, e3_P, bnbrFired) = b(clock, e2, e4);
(cnextClock, e3_C, e4_P, cnbrFired) = c(clock, e3);

clock= Min(anextClock , Min(bnextClock , cnextClock));



positiveValues = ( e2 >= 0) 
	and ( e3 >= 0) 
	and ( e4 >= 0) 
	and ( e1 >= 0) 
	and ( anbrFired  >=  0) 
	and ( bnbrFired  >=  0) 
	and ( cnbrFired  >=  0) ;
--%MAIN;

--%PROPERTY  "Ok, all variables are positive "  positiveValues;


tel;


