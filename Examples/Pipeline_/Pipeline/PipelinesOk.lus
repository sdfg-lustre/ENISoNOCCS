
include "../BitBlasting/toInclude_BitBlasting_ok.lus"



--------------instruction with --------------------
--node P(const n: int; B: bool^n) returns (p:bool);
--let
-- p = with n=1 then B[0]
--      else XOR(B[n-1] , P(n-1,B[0..n-2]));
--tel



------------------------------SDFG weights
const IN_Z=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];	const OUT_Z=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; const Z0=[0 , 0 , 0 , 0,  0 , 0  ,0  ,0];
const IN_V=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];	const OUT_V=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; const V0=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];
const IN_W=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];	const OUT_W=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; const W0=[1 , 1 , 0 , 0,  0 , 0  ,0  ,0];
const IN_A=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];                                                  const A0=[0, 0 , 0 , 0,  0 , 0  ,0  ,0];


const IN_P=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; 





--***************************************************************************
--******************node wait***********************************************

node Wait (A, V, W: UsrInt) returns ( consA, consV,  consW, prodV, prodZ:UsrInt;  WaitFired:bool);
let

WaitFired =UsrIntGte (A, IN_A) and UsrIntGte (V, IN_V) and UsrIntGte(W, IN_W);
(consA, consV,  consW, prodV, prodZ) =	if 	DoFireWait (A,V,W, UsrInt_4) then FireWait (UsrInt_4) 
				else if DoFireWait (A,V,W, UsrInt_3) then FireWait (UsrInt_3) 
				else if DoFireWait (A,V,W, UsrInt_2) then FireWait (UsrInt_2)  
				else if DoFireWait (A,V, W, UsrInt_1) then FireWait (UsrInt_1) 
				else 					FireWait (UsrInt_0);
tel

----
node DoFireWait (A, V, W, times:UsrInt) returns ( yes: bool);
let
yes = if UsrIntGte (A, FourBitsMult(times, IN_A)) and 
	 UsrIntGte (V, FourBitsMult(times, IN_V))and  UsrIntGte (W, FourBitsMult(times, IN_W)) then true 
	else false;
tel
---

node FireWait (times:UsrInt) returns (consA, consV, consW, prodV, prodZ: UsrInt);
let
consA= FourBitsMult(times, IN_A) ;
consV= FourBitsMult(times, IN_V);
consW= FourBitsMult(times, IN_W);
prodV= FourBitsMult(times,OUT_V) ;
prodZ= FourBitsMult(times,OUT_Z) ;
tel
----


--***************************************************************************
--*****************node Ta**************************************************
 node Ta (Z: UsrInt) returns (consZ,  prodW:UsrInt;  TaFired:bool);
let

TaFired =UsrIntGte (Z, IN_Z) ;
(consZ,  prodW) =	if 	DoFireTa (Z, UsrInt_4)  then FireTa (UsrInt_4) 
				else if DoFireTa (Z, UsrInt_3) then FireTa (UsrInt_3) 
				else if DoFireTa (Z, UsrInt_2) then FireTa (UsrInt_2)  
				else if DoFireTa (Z,  UsrInt_1) then FireTa (UsrInt_1) 
				else 					FireTa (UsrInt_0);
tel

----
node DoFireTa (Z,  times:UsrInt) returns ( yes: bool);
let
yes = if UsrIntGte (Z, FourBitsMult(times, IN_Z))  then true 
	else false;
tel
---

node FireTa (times:UsrInt) returns (consZ,  prodW: UsrInt);
let
consZ= FourBitsMult(times, IN_Z);
prodW= FourBitsMult(times,OUT_W) ;

tel
----


--***************************************************************************
--*******************node generator****************************************

node generator (P, A: UsrInt) returns (prodA: UsrInt;  generatorFired: bool);
let

generatorFired =  UsrIntGte (P, IN_P) and UsrIntLte (A, UsrInt_10);
(prodA) = if generatorFired 	then (P)  else (UsrInt_0);

tel


--***************************************************************************
--********************top****************************************************
node top (P:UsrInt) returns (generatorFired, TaFired, WaitFired, noErreur: bool; A: UsrInt);

var    prodZ, prodW, prodV,  prodA, consA, consZ, delayedZ , consV, delayedV,  consW, delayedW,     
 Z, V, W, A1,  Z1, V1, W1: UsrInt;

---variabes pour les propreiétes
P0, P1, P2, P3, P1bis,  P2bis, P3bis, P4bis: bool;


let

(prodA,   generatorFired) =  generator (P,A);
(consA, consV,   consW, delayedV, delayedZ, WaitFired) = Wait(A,V, W);
(consZ,  delayedW, TaFired)= Ta(Z);

Z1= UsrIntPlus (UsrIntMinus (Z, consZ), prodZ);   Z= Z0-> (pre Z1);
V1= UsrIntPlus (UsrIntMinus (V, consV), prodV);     V= V0-> (pre V1);
W1= UsrIntPlus (UsrIntMinus (W, consW), prodW);     W= W0-> (pre W1);
A1= UsrIntPlus (UsrIntMinus (A, consA), prodA);   A= A0-> (pre A1);

----------------------------------------MAJ des delais des noeuds
--si delai du noeud est X cycles alors il faut X-1 "pre"
-- delai == 2
--prodV= UsrInt_0->(pre (UsrInt_0-> pre delayedV));
--prodZ= UsrInt_0->(pre (UsrInt_0-> pre delayedZ));
prodV= UsrInt_0-> pre delayedV;
prodZ= UsrInt_0-> pre delayedZ;


--si delai du noeud est X cycles alors il faut X-1 "pre"
--delai Ta= 8
--prodW= UsrInt_0->(pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre delayedW)))))));
prodW = UsrInt_0->(pre (UsrInt_0-> (pre (UsrInt_0-> (pre  (UsrInt_0->(pre (UsrInt_0-> (pre (UsrInt_0-> (pre  (UsrInt_0-> (pre delayedW )))))))))))));
 

------------------------------------------ les signaux suivants ajoutÃ©s pour la vÃ©rification du modele------------------------------------
P0= UsrIntGte (A,  UsrInt_0) and UsrIntGte (V,  UsrInt_0) and UsrIntGte (W,  UsrInt_0) and UsrIntGte (Z,  UsrInt_0);

----P1: le pipeline n'est pas pas débordé

P1= UsrIntGte (W,  UsrInt_0) ; 

--------P2: si Ta est activé alors il est activé une seule fois dans ce cycle et n'a pas été activé dans les cycles précedents.
----si durée de wait est X alors il faut X-1 "pre" dans "not (pre  pre ....pre TaFired)"
--P2= TaFired => UsrIntLte (consZ, UsrInt_1) and not (pre  TaFired) and not (pre  pre TaFired) and not (pre  pre pre TaFired);
P2= TaFired => UsrIntLte (consZ, UsrInt_1) and not (pre  TaFired) ;

------P3: si Ta n'est pas activé c'est qu'il y a pas de jetons, ou le pipeline est plein ou Ta a été activé dans l'un des cycles précédent
----si durée de wait est X alors il faut X-1 "pre" dans "pre  pre ....pre TaFired"
--P3=  not TaFired => UsrIntEq(Z, UsrInt_0)  or  UsrIntEq (pre pre W,  UsrInt_0)  or    (pre  TaFired) or  (pre  pre TaFired) or  (pre  pre pre TaFired);

P3=  not TaFired => UsrIntEq(pre pre A, UsrInt_0)  or  UsrIntEq (pre pre W,  UsrInt_0)  or    (pre  TaFired);


noErreur= P0 and P1 and P2 and P3 ;


----------------
--l'autre ensemble  equivalent de propriétes
P1bis= UsrIntGte (W,  UsrInt_0) ; 
P2bis= WaitFired =>  not (pre  WaitFired) ;

P3bis=  not WaitFired => UsrIntEq(A, UsrInt_0)  or  UsrIntEq ( W,  UsrInt_0)  or    (pre  WaitFired);
P4bis= not TaFired=> not (pre pre WaitFired);

--noErreur=  P1bis and P2bis and P3bis and P4bis ;
 

assert UsrIntLte(P, UsrInt_2) and UsrIntGte(P, UsrInt_0);

tel

--*****************************************************************************
--********************test***************************************************r
node test (P:UsrInt) returns ( noErreur: bool);
 var
generatorFired, TaFired, WaitFired:bool; 
A: UsrInt;

let
(generatorFired, TaFired, WaitFired, noErreur,  A)= top(P);
tel

