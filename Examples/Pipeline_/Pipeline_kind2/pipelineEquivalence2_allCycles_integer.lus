--** This lustre code is generated automatically on 16 sept. 2020 11:07:00 PM
--**It corresponds to a translation to Lustre of the  SDFG model  of the design "example" 



--**************** Const Rates ****************--

const Wait_A_rate_in = 1;
const Wait_W_rate_in = 1;
const Wait_Vin_rate_in = 1;
const Wait_Vout_rate_out = 1;
const Wait_Z_rate_out = 1;
const Ta_Z_rate_in = 1;
const Ta_W_rate_out = 1;
const WaitBis_A_rate_in = 1;
const WaitBis_W_rate_in = 1;
const WaitBis_Z_rate_out = 1;
const TaBis_Z_rate_in = 1;
const TaBis_W_rate_out = 1;
const TaBis_Vin_rate_in = 1;
const TaBis_Vout_rate_out = 1;

--**************** Init Channel ****************--

const V_I = 1 ;
const W_I = 8 ;
const Z_I = 0 ;
const Vbis_I = 1 ;
const Wbis_I = 8 ;
const Zbis_I = 0 ;

const InBis_I = 0 ;
const In_I = 0 ;

--**************** Actors Translation ****************--

node Wait(A, W, Vin :int) returns (A_C, W_C, Vin_C, Vout_P, Z_P :int; WaitnbrFired, WaitnbrEnd : int );

let
WaitnbrFired= if WaitDoFire(A, W, Vin,3) then 3
		else if WaitDoFire(A, W, Vin,2) then 2
		else if WaitDoFire(A, W, Vin,1) then 1
		else 0;

WaitnbrEnd= 0 -> pre (0 -> pre (0 -> pre (WaitnbrFired)));



(A_C, W_C, Vin_C) = ((WaitnbrFired * Wait_A_rate_in), (WaitnbrFired * Wait_W_rate_in), (WaitnbrFired * Wait_Vin_rate_in));

(Vout_P, Z_P) = ((WaitnbrEnd * Wait_Vout_rate_out), (WaitnbrEnd * Wait_Z_rate_out));

tel;
------------------
node WaitDoFire(A, W, Vin :int; times: int) returns ( yes: bool);
let

yes = if  (A>=  (times * Wait_A_rate_in)) 
	and  (W>=  (times * Wait_W_rate_in)) 
	and  (Vin>=  (times * Wait_Vin_rate_in)) 
	then true 
	else false;

tel;
------------------
node Ta(Z :int) returns (Z_C, W_P :int; TanbrFired, TanbrEnd : int );

let
TanbrFired= if TaDoFire(Z,3) then 3
		else if TaDoFire(Z,2) then 2
		else if TaDoFire(Z,1) then 1
		else 0;

TanbrEnd= 0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (TanbrFired)))))))))))))))))))))))))));



(Z_C) = ((TanbrFired * Ta_Z_rate_in));

(W_P) = ((TanbrEnd * Ta_W_rate_out));

tel;
------------------
node TaDoFire(Z :int; times: int) returns ( yes: bool);
let

yes = if  (Z>=  (times * Ta_Z_rate_in)) 
	then true 
	else false;

tel;
------------------
node WaitBis(A, W :int) returns (A_C, W_C, Z_P :int; WaitBisnbrFired, WaitBisnbrEnd : int );

let
WaitBisnbrFired= if WaitBisDoFire(A, W,3) then 3
		else if WaitBisDoFire(A, W,2) then 2
		else if WaitBisDoFire(A, W,1) then 1
		else 0;

WaitBisnbrEnd= 0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (0 -> pre (WaitBisnbrFired)))))))))))))))))))))))))));



(A_C, W_C) = ((WaitBisnbrFired * WaitBis_A_rate_in), (WaitBisnbrFired * WaitBis_W_rate_in));

(Z_P) = ((WaitBisnbrEnd * WaitBis_Z_rate_out));

tel;
------------------
node WaitBisDoFire(A, W :int; times: int) returns ( yes: bool);
let

yes = if  (A>=  (times * WaitBis_A_rate_in)) 
	and  (W>=  (times * WaitBis_W_rate_in)) 
	then true 
	else false;

tel;
------------------
node TaBis(Z, Vin :int) returns (Z_C, W_P, Vin_C, Vout_P :int; TaBisnbrFired, TaBisnbrEnd : int );

let
TaBisnbrFired= if TaBisDoFire(Z, Vin,3) then 3
		else if TaBisDoFire(Z, Vin,2) then 2
		else if TaBisDoFire(Z, Vin,1) then 1
		else 0;

TaBisnbrEnd= 0 -> pre (0 -> pre (0 -> pre (TaBisnbrFired)));



(Z_C, Vin_C) = ((TaBisnbrFired * TaBis_Z_rate_in), (TaBisnbrFired * TaBis_Vin_rate_in));

(W_P, Vout_P) = ((TaBisnbrEnd * TaBis_W_rate_out), (TaBisnbrEnd * TaBis_Vout_rate_out));

tel;
------------------
node TaBisDoFire(Z, Vin :int; times: int) returns ( yes: bool);
let

yes = if  (Z>=  (times * TaBis_Z_rate_in)) 
	and  (Vin>=  (times * TaBis_Vin_rate_in)) 
	then true 
	else false;

tel;
------------------
node top (InBis_P, In_P : int)
returns (V, W, Z, Vbis, Wbis, Zbis, InBis, In, WaitnbrFired, TanbrFired, WaitBisnbrFired, TaBisnbrFired: int);

-------------- Les variables -------------- 

var

V_C, V_P: int; 
W_C, W_P: int; 
Z_C, Z_P: int; 
Vbis_C, Vbis_P: int; 
Wbis_C, Wbis_P: int; 
Zbis_C, Zbis_P: int; 
InBis_C : int;
In_C : int;
WaitnbrEnd, TanbrEnd, WaitBisnbrEnd, TaBisnbrEnd : int; 

WaitnbrRun, TanbrRun, WaitBisnbrRun, TaBisnbrRun : int; 

positiveValues, noDeadlock: bool;


let

V = V_I -> pre  (   V-V_C)+ V_P;
W = W_I -> pre  (   W-W_C)+ W_P;
Z = Z_I -> pre  (   Z-Z_C)+ Z_P;
Vbis = Vbis_I -> pre  (   Vbis-Vbis_C)+ Vbis_P;
Wbis = Wbis_I -> pre  (   Wbis-Wbis_C)+ Wbis_P;
Zbis = Zbis_I -> pre  (   Zbis-Zbis_C)+ Zbis_P;

InBis = InBis_P -> pre  ( InBis-InBis_C)+ InBis_P ;
In = In_P -> pre  ( In-In_C)+ In_P ;


(In_C, W_C, V_C, V_P, Z_P, WaitnbrFired, WaitnbrEnd ) = Wait(In, W, V);
(Z_C, W_P, TanbrFired, TanbrEnd ) = Ta(Z);
(InBis_C, Wbis_C, Zbis_P, WaitBisnbrFired, WaitBisnbrEnd ) = WaitBis(InBis, Wbis);
(Zbis_C, Wbis_P, Vbis_C, Vbis_P, TaBisnbrFired, TaBisnbrEnd ) = TaBis(Zbis, Vbis);

WaitnbrRun=  WaitnbrFired  -> (pre WaitnbrRun) +WaitnbrFired - WaitnbrEnd ;

TanbrRun=  TanbrFired  -> (pre TanbrRun) +TanbrFired - TanbrEnd ;

WaitBisnbrRun=  WaitBisnbrFired  -> (pre WaitBisnbrRun) +WaitBisnbrFired - WaitBisnbrEnd ;

TaBisnbrRun=  TaBisnbrFired  -> (pre TaBisnbrRun) +TaBisnbrFired - TaBisnbrEnd ;


positiveValues = ( V>=   0) 
	and  ( W>=   0) 
	and  ( Z>=   0) 
	and  ( Vbis>=   0) 
	and  ( Wbis>=   0) 
	and  ( Zbis>=   0) 
	and  ( InBis>=  0) 
	and  ( In>=  0) 
	and  ( WaitnbrFired >= 0) 
	and  ( TanbrFired >= 0) 
	and  ( WaitBisnbrFired >= 0) 
	and  ( TaBisnbrFired >= 0) ;

noDeadlock = ( WaitnbrRun >= 1) 
	or  ( TanbrRun >= 1) 
	or  ( WaitBisnbrRun >= 1) 
	or  ( TaBisnbrRun >= 1);

assert InBis_P  >=0; 
 
assert In_P  >=0; 
 
--%MAIN;

--%PROPERTY  "Ok, all variables are positive "  positiveValues;


--%PROPERTY  "Deadlock free "  noDeadlock;


tel;

