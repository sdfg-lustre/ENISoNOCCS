include "./toInclude_BitBlasting_ok.lus"

const maxValue = [0,0,0,1,0,0,0,0];

--**************** Const Rates ****************--

const Wait_A_rate_in = [1,0,0,0,0,0,0,0];
const Wait_W_rate_in = [1,0,0,0,0,0,0,0];
const Wait_Vin_rate_in = [1,0,0,0,0,0,0,0];
const Wait_Vout_rate_out = [1,0,0,0,0,0,0,0];
const Wait_Z_rate_out = [1,0,0,0,0,0,0,0];
const Ta_Z_rate_in = [1,0,0,0,0,0,0,0];
const Ta_W_rate_out = [1,0,0,0,0,0,0,0];
const WaitBis_A_rate_in = [1,0,0,0,0,0,0,0];
const WaitBis_W_rate_in = [1,0,0,0,0,0,0,0];
const WaitBis_Vin_rate_in = [1,0,0,0,0,0,0,0];
const WaitBis_Vout_rate_out = [1,0,0,0,0,0,0,0];
const WaitBis_Z_rate_out = [1,0,0,0,0,0,0,0];
const TaBis_Z_rate_in = [1,0,0,0,0,0,0,0];
const TaBis_W_rate_out = [1,0,0,0,0,0,0,0];

--**************** Init Channel ****************--

const V_I = [1,0,0,0,0,0,0,0];
const W_I = [1,1,0,0,0,0,0,0];
const Z_I = [0,0,0,0,0,0,0,0];
const Vbis_I = [1,0,0,0,0,0,0,0];
const Wbis_I = [1,1,0,0,0,0,0,0];
const Zbis_I = [0,0,0,0,0,0,0,0];

const InBis_I = [0,0,0,0,0,0,0,0];
const In_I = [0,0,0,0,0,0,0,0];

--**************** Nodes Declaration ****************--

node Wait(A, W, Vin :UsrInt) returns (A_C, W_C, Vin_C, Vout_P, Z_P :UsrInt; WaitnbrFired: UsrInt );

var
Vout_PD, Z_PD :UsrInt;
let
WaitnbrFired= if WaitDoFire(A, W, Vin,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(A_C, W_C, Vin_C,Vout_PD, Z_PD) = (UsrIntMult(WaitnbrFired, Wait_A_rate_in),UsrIntMult(WaitnbrFired, Wait_W_rate_in),UsrIntMult(WaitnbrFired, Wait_Vin_rate_in),UsrIntMult(WaitnbrFired, Wait_Vout_rate_out),UsrIntMult(WaitnbrFired, Wait_Z_rate_out));

Vout_P = UsrInt_0 -> pre (Vout_PD);

Z_P = UsrInt_0 -> pre (Z_PD);


tel;
------------------
node WaitDoFire(A, W, Vin,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(A, UsrIntMult(times, Wait_A_rate_in)) 
	and UsrIntGte(W, UsrIntMult(times, Wait_W_rate_in)) 
	and UsrIntGte(Vin, UsrIntMult(times, Wait_Vin_rate_in)) 
	then true 
	else false;

tel;
------------------
node Ta(Z :UsrInt) returns (Z_C, W_P :UsrInt; TanbrFired: UsrInt );

var
W_PD :UsrInt;
let
TanbrFired= if TaDoFire(Z,UsrInt_3) then UsrInt_3
		else if TaDoFire(Z,UsrInt_2) then UsrInt_2
		else if TaDoFire(Z,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(Z_C,W_PD) = (UsrIntMult(TanbrFired, Ta_Z_rate_in),UsrIntMult(TanbrFired, Ta_W_rate_out));

W_P = UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (W_PD)))))));


tel;
------------------
node TaDoFire(Z,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(Z, UsrIntMult(times, Ta_Z_rate_in)) 
	then true 
	else false;

tel;
------------------
node WaitBis(A, W, Vin :UsrInt) returns (A_C, W_C, Vin_C, Vout_P, Z_P :UsrInt; WaitBisnbrFired: UsrInt );

var
Vout_PD, Z_PD :UsrInt;
let
WaitBisnbrFired= if WaitBisDoFire(A, W, Vin,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(A_C, W_C, Vin_C,Vout_PD, Z_PD) = (UsrIntMult(WaitBisnbrFired, WaitBis_A_rate_in),UsrIntMult(WaitBisnbrFired, WaitBis_W_rate_in),UsrIntMult(WaitBisnbrFired, WaitBis_Vin_rate_in),UsrIntMult(WaitBisnbrFired, WaitBis_Vout_rate_out),UsrIntMult(WaitBisnbrFired, WaitBis_Z_rate_out));

Vout_P = UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (Vout_PD)))))));

Z_P = UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (Z_PD)))))));


tel;
------------------
node WaitBisDoFire(A, W, Vin,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(A, UsrIntMult(times, WaitBis_A_rate_in)) 
	and UsrIntGte(W, UsrIntMult(times, WaitBis_W_rate_in)) 
	and UsrIntGte(Vin, UsrIntMult(times, WaitBis_Vin_rate_in)) 
	then true 
	else false;

tel;
------------------
node TaBis(Z :UsrInt) returns (Z_C, W_P :UsrInt; TaBisnbrFired: UsrInt );

var
W_PD :UsrInt;
let
TaBisnbrFired= if TaBisDoFire(Z,UsrInt_3) then UsrInt_3
		else if TaBisDoFire(Z,UsrInt_2) then UsrInt_2
		else if TaBisDoFire(Z,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(Z_C,W_PD) = (UsrIntMult(TaBisnbrFired, TaBis_Z_rate_in),UsrIntMult(TaBisnbrFired, TaBis_W_rate_out));

W_P = UsrInt_0 -> pre (W_PD);


tel;
------------------
node TaBisDoFire(Z,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(Z, UsrIntMult(times, TaBis_Z_rate_in)) 
	then true 
	else false;

tel;
------------------

--**************** Node Top Declaration ****************--

node top (In_P: UsrInt) returns (V, W, Z, Vbis, Wbis, Zbis, InBis, In, WaitnbrFired, TanbrFired, WaitBisnbrFired, TaBisnbrFired:UsrInt);

-------------- Les variables -------------- 

var

V_C, V_P: UsrInt; 
W_C, W_P: UsrInt; 
Z_C, Z_P: UsrInt; 
Vbis_C, Vbis_P: UsrInt; 
Wbis_C, Wbis_P: UsrInt; 
Zbis_C, Zbis_P: UsrInt; 
InBis_C : UsrInt;
In_C , In_var: UsrInt;

let

V = V_I -> pre UsrIntPlus( UsrIntMinus( V,V_C), V_P);
W = W_I -> pre UsrIntPlus( UsrIntMinus( W,W_C), W_P);
Z = Z_I -> pre UsrIntPlus( UsrIntMinus( Z,Z_C), Z_P);
Vbis = Vbis_I -> pre UsrIntPlus( UsrIntMinus( Vbis,Vbis_C), Vbis_P);
Wbis = Wbis_I -> pre UsrIntPlus( UsrIntMinus( Wbis,Wbis_C), Wbis_P);
Zbis = Zbis_I -> pre UsrIntPlus( UsrIntMinus( Zbis,Zbis_C), Zbis_P);

 
In_var =    UsrInt_0 ->   if UsrIntLt(UsrIntPlus( UsrIntMinus( In,  In_C),  In_P), maxValue)  then   In_P else  UsrInt_0 ;

InBis = InBis_I -> pre UsrIntPlus( UsrIntMinus(InBis,InBis_C), In_var) ;
				 
In    = In_I    -> pre UsrIntPlus( UsrIntMinus(In,In_C), In_var);

(In_C, W_C, V_C, V_P, Z_P, WaitnbrFired) = Wait(In, W, V);
(Z_C, W_P, TanbrFired) = Ta(Z);
(InBis_C, Wbis_C, Vbis_C, Vbis_P, Zbis_P, WaitBisnbrFired) = WaitBis(InBis, Wbis, Vbis);
(Zbis_C, Wbis_P, TaBisnbrFired) = TaBis(Zbis);


tel;


--**************** Node Harness Declaration ****************--

node Harness (In_P: UsrInt) returns (noError :bool)

var

V, W, Z, Vbis, Wbis, Zbis, InBis, In, WaitnbrFired, TanbrFired, WaitBisnbrFired, TaBisnbrFired:UsrInt;

positiveValues: bool;

let

(V, W, Z, Vbis, Wbis, Zbis, InBis, In, WaitnbrFired, TanbrFired, WaitBisnbrFired, TaBisnbrFired) = top(In_P);

positiveValues = UsrIntGte( V, UsrInt_0) 
	and UsrIntGte( W, UsrInt_0) 
	and UsrIntGte( Z, UsrInt_0) 
	and UsrIntGte( Vbis, UsrInt_0) 
	and UsrIntGte( Wbis, UsrInt_0) 
	and UsrIntGte( Zbis, UsrInt_0) 
	and UsrIntGte( InBis, UsrInt_0) 
	and UsrIntGte( In, UsrInt_0) 
	and UsrIntGte( WaitnbrFired , UsrInt_0) 
	and UsrIntGte( TanbrFired , UsrInt_0) 
	and UsrIntGte( WaitBisnbrFired , UsrInt_0) 
	and UsrIntGte( TaBisnbrFired , UsrInt_0) ;

noError= positiveValues and true;
assert UsrIntLte(In_P, UsrInt_3) and UsrIntGte(In_P, UsrInt_0);

tel
