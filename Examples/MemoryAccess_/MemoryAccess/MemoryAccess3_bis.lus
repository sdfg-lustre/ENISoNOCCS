include "./toInclude_BitBlasting_ok.lus"

const maxValue = [1,1,1,1,0,0,0,0];

--**************** Const Rates ****************--

const r1_e1_rate_out = [1,1,0,0,0,0,0,0];
const r1_e2_rate_in = [1,1,0,0,0,0,0,0];
const m1_e2_rate_out = [1,0,0,0,0,0,0,0];
const m1_e1_rate_in = [1,0,0,0,0,0,0,0];
const m1_e3_rate_out = [1,0,0,0,0,0,0,0];
const m1_e4_rate_in = [1,0,0,0,0,0,0,0];
const m1_e7_rate_out = [1,0,0,0,0,0,0,0];
const m1_e8_rate_in = [1,0,0,0,0,0,0,0];
const m2_e3_rate_in = [1,0,0,0,0,0,0,0];
const m2_e4_rate_out = [1,0,0,0,0,0,0,0];
const m2_e5_rate_out = [1,0,0,0,0,0,0,0];
const m2_e6_rate_in = [1,0,0,0,0,0,0,0];
const a1_e5_rate_in = [1,0,0,0,0,0,0,0];
const a1_e7_rate_in = [1,0,0,0,0,0,0,0];
const a1_e8_rate_out = [1,0,0,0,0,0,0,0];
const a1_e9_rate_in = [1,0,0,0,0,0,0,0];
const a1_e10_rate_out = [1,0,0,0,0,0,0,0];
const a2_e6_rate_out = [1,0,0,0,0,0,0,0];
const a2_e10_rate_in = [1,0,0,0,0,0,0,0];
const a2_e9_rate_out = [1,0,0,0,0,0,0,0];
const a2_e11_rate_in = [1,0,0,0,0,0,0,0];
const a2_e12_rate_out = [1,0,0,0,0,0,0,0];
const r0_e11_rate_out = [1,1,0,0,0,0,0,0];
const r0_e12_rate_in = [1,1,0,0,0,0,0,0];

--**************** Init Channel ****************--

const e1_I = [0,0,0,0,0,0,0,0];
const e2_I = [1,1,0,0,0,0,0,0];
const e3_I = [0,0,0,0,0,0,0,0];
const e4_I = [1,0,0,0,0,0,0,0];
const e5_I = [1,0,0,0,0,0,0,0];
const e6_I = [0,0,0,0,0,0,0,0];
const e7_I = [1,0,0,0,0,0,0,0];
const e8_I = [0,0,0,0,0,0,0,0];
const e9_I = [1,0,0,0,0,0,0,0];
const e10_I = [0,0,0,0,0,0,0,0];
const e11_I = [1,1,0,0,0,0,0,0];
const e12_I = [0,0,0,0,0,0,0,0];


--**************** Nodes Declaration ****************--

node r1(e2 :UsrInt) returns (e1_P, e2_C :UsrInt; r1nbrFired: UsrInt );

let
r1nbrFired= if r1DoFire(e2,UsrInt_3) then UsrInt_3
		else if r1DoFire(e2,UsrInt_2) then UsrInt_2
		else if r1DoFire(e2,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(e2_C,e1_P) = (UsrIntMult(r1nbrFired, r1_e2_rate_in),UsrIntMult(r1nbrFired, r1_e1_rate_out));

tel;
------------------
node r1DoFire(e2,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(e2, UsrIntMult(times, r1_e2_rate_in)) 
	then true 
	else false;

tel;
------------------
node m1(e1, e4, e8 :UsrInt) returns (e2_P, e1_C, e3_P, e4_C, e7_P, e8_C :UsrInt; m1nbrFired: UsrInt );

var
e2_PD, e3_PD, e7_PD :UsrInt;
let
m1nbrFired= if m1DoFire(e1, e4, e8,UsrInt_3) then UsrInt_3
		else if m1DoFire(e1, e4, e8,UsrInt_2) then UsrInt_2
		else if m1DoFire(e1, e4, e8,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(e1_C, e4_C, e8_C,e2_PD, e3_PD, e7_PD) = (UsrIntMult(m1nbrFired, m1_e1_rate_in),UsrIntMult(m1nbrFired, m1_e4_rate_in),UsrIntMult(m1nbrFired, m1_e8_rate_in),UsrIntMult(m1nbrFired, m1_e2_rate_out),UsrIntMult(m1nbrFired, m1_e3_rate_out),UsrIntMult(m1nbrFired, m1_e7_rate_out));

e2_P = UsrInt_0 -> pre (e2_PD);

e3_P = UsrInt_0 -> pre (e3_PD);

e7_P = UsrInt_0 -> pre (e7_PD);


tel;
------------------
node m1DoFire(e1, e4, e8,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(e1, UsrIntMult(times, m1_e1_rate_in)) 
	and UsrIntGte(e4, UsrIntMult(times, m1_e4_rate_in)) 
	and UsrIntGte(e8, UsrIntMult(times, m1_e8_rate_in)) 
	then true 
	else false;

tel;
------------------
node m2(e3, e6 :UsrInt) returns (e3_C, e4_P, e5_P, e6_C :UsrInt; m2nbrFired: UsrInt );

var
e4_PD, e5_PD :UsrInt;
let
m2nbrFired= if m2DoFire(e3, e6,UsrInt_3) then UsrInt_3
		else if m2DoFire(e3, e6,UsrInt_2) then UsrInt_2
		else if m2DoFire(e3, e6,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(e3_C, e6_C,e4_PD, e5_PD) = (UsrIntMult(m2nbrFired, m2_e3_rate_in),UsrIntMult(m2nbrFired, m2_e6_rate_in),UsrIntMult(m2nbrFired, m2_e4_rate_out),UsrIntMult(m2nbrFired, m2_e5_rate_out));

e4_P = UsrInt_0 -> pre (e4_PD);

e5_P = UsrInt_0 -> pre (e5_PD);


tel;
------------------
node m2DoFire(e3, e6,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(e3, UsrIntMult(times, m2_e3_rate_in)) 
	and UsrIntGte(e6, UsrIntMult(times, m2_e6_rate_in)) 
	then true 
	else false;

tel;
------------------
node a1(e5, e7, e9 :UsrInt) returns (e5_C, e7_C, e8_P, e9_C, e10_P :UsrInt; a1nbrFired: UsrInt );

var
e8_PD, e10_PD :UsrInt;
let
a1nbrFired= if a1DoFire(e5, e7, e9,UsrInt_3) then UsrInt_3
		else if a1DoFire(e5, e7, e9,UsrInt_2) then UsrInt_2
		else if a1DoFire(e5, e7, e9,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(e5_C, e7_C, e9_C,e8_PD, e10_PD) = (UsrIntMult(a1nbrFired, a1_e5_rate_in),UsrIntMult(a1nbrFired, a1_e7_rate_in),UsrIntMult(a1nbrFired, a1_e9_rate_in),UsrIntMult(a1nbrFired, a1_e8_rate_out),UsrIntMult(a1nbrFired, a1_e10_rate_out));

e8_P = UsrInt_0 -> pre (UsrInt_0 -> pre (e8_PD));

e10_P = UsrInt_0 -> pre (UsrInt_0 -> pre (e10_PD));


tel;
------------------
node a1DoFire(e5, e7, e9,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(e5, UsrIntMult(times, a1_e5_rate_in)) 
	and UsrIntGte(e7, UsrIntMult(times, a1_e7_rate_in)) 
	and UsrIntGte(e9, UsrIntMult(times, a1_e9_rate_in)) 
	then true 
	else false;

tel;
------------------
node a2(e10, e11 :UsrInt) returns (e6_P, e10_C, e9_P, e11_C, e12_P :UsrInt; a2nbrFired: UsrInt );

var
e6_PD, e9_PD, e12_PD :UsrInt;
let
a2nbrFired= if a2DoFire(e10, e11,UsrInt_3) then UsrInt_3
		else if a2DoFire(e10, e11,UsrInt_2) then UsrInt_2
		else if a2DoFire(e10, e11,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(e10_C, e11_C,e6_PD, e9_PD, e12_PD) = (UsrIntMult(a2nbrFired, a2_e10_rate_in),UsrIntMult(a2nbrFired, a2_e11_rate_in),UsrIntMult(a2nbrFired, a2_e6_rate_out),UsrIntMult(a2nbrFired, a2_e9_rate_out),UsrIntMult(a2nbrFired, a2_e12_rate_out));

e6_P = UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (e6_PD)));

e9_P = UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (e9_PD)));

e12_P = UsrInt_0 -> pre (UsrInt_0 -> pre (UsrInt_0 -> pre (e12_PD)));


tel;
------------------
node a2DoFire(e10, e11,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(e10, UsrIntMult(times, a2_e10_rate_in)) 
	and UsrIntGte(e11, UsrIntMult(times, a2_e11_rate_in)) 
	then true 
	else false;

tel;
------------------
node r0(e12 :UsrInt) returns (e11_P, e12_C :UsrInt; r0nbrFired: UsrInt );

let
r0nbrFired= if r0DoFire(e12,UsrInt_3) then UsrInt_3
		else if r0DoFire(e12,UsrInt_2) then UsrInt_2
		else if r0DoFire(e12,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(e12_C,e11_P) = (UsrIntMult(r0nbrFired, r0_e12_rate_in),UsrIntMult(r0nbrFired, r0_e11_rate_out));

tel;
------------------
node r0DoFire(e12,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(e12, UsrIntMult(times, r0_e12_rate_in)) 
	then true 
	else false;

tel;
------------------

--**************** Node Top Declaration ****************--

node top (in: UsrInt) returns (e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, r1nbrFired, m1nbrFired, m2nbrFired, a1nbrFired, a2nbrFired, r0nbrFired:UsrInt);

-------------- Les variables -------------- 

var

e1_C, e1_P: UsrInt; 
e2_C, e2_P: UsrInt; 
e3_C, e3_P: UsrInt; 
e4_C, e4_P: UsrInt; 
e5_C, e5_P: UsrInt; 
e6_C, e6_P: UsrInt; 
e7_C, e7_P: UsrInt; 
e8_C, e8_P: UsrInt; 
e9_C, e9_P: UsrInt; 
e10_C, e10_P: UsrInt; 
e11_C, e11_P: UsrInt; 
e12_C, e12_P: UsrInt; 

let

e1 = e1_I -> pre UsrIntPlus( UsrIntMinus( e1,e1_C), e1_P);
e2 = e2_I -> pre UsrIntPlus( UsrIntMinus( e2,e2_C), e2_P);
e3 = e3_I -> pre UsrIntPlus( UsrIntMinus( e3,e3_C), e3_P);
e4 = e4_I -> pre UsrIntPlus( UsrIntMinus( e4,e4_C), e4_P);
e5 = e5_I -> pre UsrIntPlus( UsrIntMinus( e5,e5_C), e5_P);
e6 = e6_I -> pre UsrIntPlus( UsrIntMinus( e6,e6_C), e6_P);
e7 = e7_I -> pre UsrIntPlus( UsrIntMinus( e7,e7_C), e7_P);
e8 = e8_I -> pre UsrIntPlus( UsrIntMinus( e8,e8_C), e8_P);
e9 = e9_I -> pre UsrIntPlus( UsrIntMinus( e9,e9_C), e9_P);
e10 = e10_I -> pre UsrIntPlus( UsrIntMinus( e10,e10_C), e10_P);
e11 = e11_I -> pre UsrIntPlus( UsrIntMinus( e11,e11_C), e11_P);
e12 = e12_I -> pre UsrIntPlus( UsrIntMinus( e12,e12_C), e12_P);



(e1_P, e2_C, r1nbrFired) = r1(e2);
(e2_P, e1_C, e3_P, e4_C, e7_P, e8_C, m1nbrFired) = m1(e1, e4, e8);
(e3_C, e4_P, e5_P, e6_C, m2nbrFired) = m2(e3, e6);
(e5_C, e7_C, e8_P, e9_C, e10_P, a1nbrFired) = a1(e5, e7, e9);
(e6_P, e10_C, e9_P, e11_C, e12_P, a2nbrFired) = a2(e10, e11);
(e11_P, e12_C, r0nbrFired) = r0(e12);


tel;


--**************** Node Harness Declaration ****************--

node Harness (in: UsrInt) returns (noError :bool)

var

e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, r1nbrFired, m1nbrFired, m2nbrFired, a1nbrFired, a2nbrFired, r0nbrFired:UsrInt;

positiveValues, P1, P2, P3, P4: bool;

let

(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10, e11, e12, r1nbrFired, m1nbrFired, m2nbrFired, a1nbrFired, a2nbrFired, r0nbrFired) = top(in);

positiveValues = UsrIntGte( e1, UsrInt_0) 
	and UsrIntGte( e2, UsrInt_0) 
	and UsrIntGte( e3, UsrInt_0) 
	and UsrIntGte( e4, UsrInt_0) 
	and UsrIntGte( e5, UsrInt_0) 
	and UsrIntGte( e6, UsrInt_0) 
	and UsrIntGte( e7, UsrInt_0) 
	and UsrIntGte( e8, UsrInt_0) 
	and UsrIntGte( e9, UsrInt_0) 
	and UsrIntGte( e10, UsrInt_0) 
	and UsrIntGte( e11, UsrInt_0) 
	and UsrIntGte( e12, UsrInt_0) 
	and UsrIntGte( r1nbrFired , UsrInt_0) 
	and UsrIntGte( m1nbrFired , UsrInt_0) 
	and UsrIntGte( m2nbrFired , UsrInt_0) 
	and UsrIntGte( a1nbrFired , UsrInt_0) 
	and UsrIntGte( a2nbrFired , UsrInt_0) 
	and UsrIntGte( r0nbrFired , UsrInt_0) ;

--P1 pas d'autoconcurrenc: not P1
P1=  not UsrIntGte( r1nbrFired , UsrInt_2) and not  UsrIntGte( m1nbrFired , UsrInt_2) and not UsrIntGte( m2nbrFired , UsrInt_2)  and not UsrIntGte( a1nbrFired , UsrInt_2) 	and not  UsrIntGte( a2nbrFired , UsrInt_2) and	not UsrIntGte( r0nbrFired , UsrInt_2) ;

--P2: la durÃ©e de la latence: 25 ou 29
P2= UsrIntEq(r0nbrFired , UsrInt_1) => 
UsrIntEq(pre pre pre pre pre         pre pre pre pre pre 
         pre pre pre pre pre         pre pre pre pre pre 
         pre pre pre pre pre            r1nbrFired , UsrInt_1) or 
UsrIntEq(pre pre pre pre pre         pre pre pre pre pre  
         pre pre pre pre pre         pre pre pre pre pre 
         pre pre pre pre pre         pre  pre pre  pre r1nbrFired , UsrInt_1);  


--P3: m1 et a2 sont // 
P3= (UsrIntEq(m1nbrFired , UsrInt_1) => UsrIntEq(a2nbrFired , UsrInt_1)) and (UsrIntEq(a2nbrFired , UsrInt_1) => UsrIntEq(m1nbrFired , UsrInt_1));
--P4: m1 et a1 ne sont pas en  //
--P4= (UsrIntEq(m1nbrFired , UsrInt_1) => not UsrIntEq(a1nbrFired , UsrInt_1)) and (UsrIntEq(a1nbrFired , UsrInt_1) => not UsrIntEq(m1nbrFired , UsrInt_1));
--P4: m2 et a1 ne sont pas en  //
P4= (UsrIntEq(m2nbrFired , UsrInt_1) => not UsrIntEq(a1nbrFired , UsrInt_1)) and (UsrIntEq(a1nbrFired , UsrInt_1) => not UsrIntEq(m2nbrFired , UsrInt_1));

noError= positiveValues and P2;

tel
