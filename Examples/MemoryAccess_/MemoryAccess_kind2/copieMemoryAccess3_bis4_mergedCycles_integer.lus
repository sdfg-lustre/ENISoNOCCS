--** This lustre code is generated automatically on 02 juin 2020 09:23:10 AM
--** It corresponds to the translation of an SDFG model (Memory Access)  to Lustre. This version produce a Lustre code having a reduced number of steps.




--**************** Const Rates ****************--

const ri_e1_rate_out = 3;
const ri_e8_rate_in = 3;
const ri_e13_rate_out = 1;
const ri_e14_rate_out = 1;
const m1_e8_rate_out = 1;
const m1_e1_rate_in = 1;
const m1_e2_rate_out = 1;
const m1_e12_rate_in = 1;
const m1_e7_rate_out = 1;
const m1_e4_rate_in = 1;
const m2_e2_rate_in = 1;
const m2_e12_rate_out = 1;
const m2_e3_rate_out = 1;
const m2_e6_rate_in = 1;
const a1_e3_rate_in = 1;
const a1_e7_rate_in = 1;
const a1_e4_rate_out = 1;
const a1_e9_rate_in = 1;
const a1_e10_rate_out = 1;
const a2_e6_rate_out = 1;
const a2_e10_rate_in = 1;
const a2_e9_rate_out = 1;
const a2_e11_rate_in = 1;
const a2_e5_rate_out = 1;
const r0_e11_rate_out = 3;
const r0_e5_rate_in = 3;
const sink1_e13_rate_in = 1;
const sink1_e15_rate_out = 1;
const sink2_e14_rate_in = 1;
const sink2_e16_rate_out = 1;

--****************  Actors' durations ****************--

const ri_maxStages  = 1;
const ri_duration  = 1;
const m1_maxStages  = 1;
const m1_duration  = 4;
const m2_maxStages  = 1;
const m2_duration  = 2;
const a1_maxStages  = 1;
const a1_duration  = 3;
const a2_maxStages  = 1;
const a2_duration  = 2;
const r0_maxStages  = 1;
const r0_duration  = 1;
const sink1_maxStages  = 1;
const sink1_duration  = 22;
const sink2_maxStages  = 1;
const sink2_duration  = 24;
const  maxDuration  = 24;

--**************** Init Channel ****************--

const e1_I = 0;
const e8_I = 3;
const e2_I = 0;
const e12_I = 1;
const e3_I = 1;
const e6_I = 0;
const e7_I = 1;
const e4_I = 0;
const e9_I = 1;
const e10_I = 0;
const e11_I = 3;
const e5_I = 0;
const e13_I = 0;
const e14_I = 0;

const e15_I = 0;
const e16_I = 0;

--************************************************--
--******* Translation of Actor: ri***************--
--************************************************--
node ri(clock, e8 :int) returns (nextClock, e1_P, e8_C, e13_P, e14_P :int; rinbrFired: int );

var
e1_PD, e13_PD, e14_PD :int;
let
rinbrFired= if riDoFire(e8,3) then 3
		else if riDoFire(e8,2) then 2
		else if riDoFire(e8,1) then 1
		else 0;

(e8_C, e1_PD, e13_PD, e14_PD) = ((rinbrFired * ri_e8_rate_in),(rinbrFired * ri_e1_rate_out),(rinbrFired * ri_e13_rate_out),(rinbrFired * ri_e14_rate_out));

e1_P = 0 -> pre e1_PD;

e13_P = 0 -> pre e13_PD;

e14_P = 0 -> pre e14_PD;

nextClock = if (rinbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorri-----------------
node riDoFire(e8,times:int) returns ( yes: bool);
let

yes = if (e8>=  (times * ri_e8_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: m1***************--
--************************************************--
node m1(clock, e1, e12, e4 :int) returns (nextClock, e8_P, e1_C, e2_P, e12_C, e7_P, e4_C :int; m1nbrFired: int );

var
e8_PD, e2_PD, e7_PD :int;
stage :int;
let
m1nbrFired= if m1DoFire(e1, e12, e4,3) then 3
		else if m1DoFire(e1, e12, e4,2) then 2
		else if m1DoFire(e1, e12, e4,1) then 1
		else 0;

(e1_C, e12_C, e4_C, e8_PD, e2_PD, e7_PD) = ((m1nbrFired * m1_e1_rate_in),(m1nbrFired * m1_e12_rate_in),(m1nbrFired * m1_e4_rate_in),(m1nbrFired * m1_e8_rate_out),(m1nbrFired * m1_e2_rate_out),(m1nbrFired * m1_e7_rate_out));

stage = if (m1nbrFired = 0) then 0 
         else   1 ;

(nextClock , e8_P, e2_P, e7_P)=m1Stage(clock, stage, 1, e8_PD, e2_PD, e7_PD); 

tel;
------------------subnode Dofire of Actorm1-----------------
node m1DoFire(e1, e12, e4,times:int) returns ( yes: bool);
let

yes = if (e1>=  (times * m1_e1_rate_in)) 
	and (e12>=  (times * m1_e12_rate_in)) 
	and (e4>=  (times * m1_e4_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of Actorm1-----------------
node m1Stage(clock,  stage, numStage, e8_PD, e2_PD, e7_PD: int) returns (rTime, e8_P, e2_P, e7_P : int);

var 
e8_PDBuffer, e2_PDBuffer, e7_PDBuffer: int; 
selected, endExecution, active : bool; 

 let 
selected = if  (stage = numStage) then true else false ; 
 endExecution= false -> if not pre (active)  then false else pre  ((rTime - clock) = 0); 
active = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre active; 
rTime = if  selected then m1_duration  else maxDuration -> 
          if  selected then m1_duration 
          else if  (pre active) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 
(e8_PDBuffer, e2_PDBuffer, e7_PDBuffer) = if selected then (e8_PD, e2_PD, e7_PD) 
                               else (0, 0, 0) 
 ->if selected then (e8_PD, e2_PD, e7_PD) 
                               else if endExecution then (0, 0, 0)
           else pre (e8_PDBuffer, e2_PDBuffer, e7_PDBuffer); 
(e8_P, e2_P, e7_P) = (0, 0, 0) ->   if endExecution then pre (e8_PDBuffer, e2_PDBuffer, e7_PDBuffer)
                                        else (0, 0, 0); 
tel; 


--************************************************--
--******* Translation of Actor: m2***************--
--************************************************--
node m2(clock, e2, e6 :int) returns (nextClock, e2_C, e12_P, e3_P, e6_C :int; m2nbrFired: int );

var
e12_PD, e3_PD :int;
stage :int;
let
m2nbrFired= if m2DoFire(e2, e6,3) then 3
		else if m2DoFire(e2, e6,2) then 2
		else if m2DoFire(e2, e6,1) then 1
		else 0;

(e2_C, e6_C, e12_PD, e3_PD) = ((m2nbrFired * m2_e2_rate_in),(m2nbrFired * m2_e6_rate_in),(m2nbrFired * m2_e12_rate_out),(m2nbrFired * m2_e3_rate_out));

stage = if (m2nbrFired = 0) then 0 
         else   1 ;

(nextClock , e12_P, e3_P)=m2Stage(clock, stage, 1, e12_PD, e3_PD); 

tel;
------------------subnode Dofire of Actorm2-----------------
node m2DoFire(e2, e6,times:int) returns ( yes: bool);
let

yes = if (e2>=  (times * m2_e2_rate_in)) 
	and (e6>=  (times * m2_e6_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of Actorm2-----------------
node m2Stage(clock,  stage, numStage, e12_PD, e3_PD: int) returns (rTime, e12_P, e3_P : int);

var 
e12_PDBuffer, e3_PDBuffer: int; 
selected, endExecution, active : bool; 

 let 
selected = if  (stage = numStage) then true else false ; 
 endExecution= false -> if not pre (active)  then false else pre  ((rTime - clock) = 0); 
active = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre active; 
rTime = if  selected then m2_duration  else maxDuration -> 
          if  selected then m2_duration 
          else if  (pre active) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 
(e12_PDBuffer, e3_PDBuffer) = if selected then (e12_PD, e3_PD) 
                               else (0, 0) 
 ->if selected then (e12_PD, e3_PD) 
                               else if endExecution then (0, 0)
           else pre (e12_PDBuffer, e3_PDBuffer); 
(e12_P, e3_P) = (0, 0) ->   if endExecution then pre (e12_PDBuffer, e3_PDBuffer)
                                        else (0, 0); 
tel; 


--************************************************--
--******* Translation of Actor: a1***************--
--************************************************--
node a1(clock, e3, e7, e9 :int) returns (nextClock, e3_C, e7_C, e4_P, e9_C, e10_P :int; a1nbrFired: int );

var
e4_PD, e10_PD :int;
stage :int;
let
a1nbrFired= if a1DoFire(e3, e7, e9,3) then 3
		else if a1DoFire(e3, e7, e9,2) then 2
		else if a1DoFire(e3, e7, e9,1) then 1
		else 0;

(e3_C, e7_C, e9_C, e4_PD, e10_PD) = ((a1nbrFired * a1_e3_rate_in),(a1nbrFired * a1_e7_rate_in),(a1nbrFired * a1_e9_rate_in),(a1nbrFired * a1_e4_rate_out),(a1nbrFired * a1_e10_rate_out));

stage = if (a1nbrFired = 0) then 0 
         else   1 ;

(nextClock , e4_P, e10_P)=a1Stage(clock, stage, 1, e4_PD, e10_PD); 

tel;
------------------subnode Dofire of Actora1-----------------
node a1DoFire(e3, e7, e9,times:int) returns ( yes: bool);
let

yes = if (e3>=  (times * a1_e3_rate_in)) 
	and (e7>=  (times * a1_e7_rate_in)) 
	and (e9>=  (times * a1_e9_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of Actora1-----------------
node a1Stage(clock,  stage, numStage, e4_PD, e10_PD: int) returns (rTime, e4_P, e10_P : int);

var 
e4_PDBuffer, e10_PDBuffer: int; 
selected, endExecution, active : bool; 

 let 
selected = if  (stage = numStage) then true else false ; 
 endExecution= false -> if not pre (active)  then false else pre  ((rTime - clock) = 0); 
active = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre active; 
rTime = if  selected then a1_duration  else maxDuration -> 
          if  selected then a1_duration 
          else if  (pre active) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 
(e4_PDBuffer, e10_PDBuffer) = if selected then (e4_PD, e10_PD) 
                               else (0, 0) 
 ->if selected then (e4_PD, e10_PD) 
                               else if endExecution then (0, 0)
           else pre (e4_PDBuffer, e10_PDBuffer); 
(e4_P, e10_P) = (0, 0) ->   if endExecution then pre (e4_PDBuffer, e10_PDBuffer)
                                        else (0, 0); 
tel; 


--************************************************--
--******* Translation of Actor: a2***************--
--************************************************--
node a2(clock, e10, e11 :int) returns (nextClock, e6_P, e10_C, e9_P, e11_C, e5_P :int; a2nbrFired: int );

var
e6_PD, e9_PD, e5_PD :int;
stage :int;
let
a2nbrFired= if a2DoFire(e10, e11,3) then 3
		else if a2DoFire(e10, e11,2) then 2
		else if a2DoFire(e10, e11,1) then 1
		else 0;

(e10_C, e11_C, e6_PD, e9_PD, e5_PD) = ((a2nbrFired * a2_e10_rate_in),(a2nbrFired * a2_e11_rate_in),(a2nbrFired * a2_e6_rate_out),(a2nbrFired * a2_e9_rate_out),(a2nbrFired * a2_e5_rate_out));

stage = if (a2nbrFired = 0) then 0 
         else   1 ;

(nextClock , e6_P, e9_P, e5_P)=a2Stage(clock, stage, 1, e6_PD, e9_PD, e5_PD); 

tel;
------------------subnode Dofire of Actora2-----------------
node a2DoFire(e10, e11,times:int) returns ( yes: bool);
let

yes = if (e10>=  (times * a2_e10_rate_in)) 
	and (e11>=  (times * a2_e11_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of Actora2-----------------
node a2Stage(clock,  stage, numStage, e6_PD, e9_PD, e5_PD: int) returns (rTime, e6_P, e9_P, e5_P : int);

var 
e6_PDBuffer, e9_PDBuffer, e5_PDBuffer: int; 
selected, endExecution, active : bool; 

 let 
selected = if  (stage = numStage) then true else false ; 
 endExecution= false -> if not pre (active)  then false else pre  ((rTime - clock) = 0); 
active = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre active; 
rTime = if  selected then a2_duration  else maxDuration -> 
          if  selected then a2_duration 
          else if  (pre active) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 
(e6_PDBuffer, e9_PDBuffer, e5_PDBuffer) = if selected then (e6_PD, e9_PD, e5_PD) 
                               else (0, 0, 0) 
 ->if selected then (e6_PD, e9_PD, e5_PD) 
                               else if endExecution then (0, 0, 0)
           else pre (e6_PDBuffer, e9_PDBuffer, e5_PDBuffer); 
(e6_P, e9_P, e5_P) = (0, 0, 0) ->   if endExecution then pre (e6_PDBuffer, e9_PDBuffer, e5_PDBuffer)
                                        else (0, 0, 0); 
tel; 


--************************************************--
--******* Translation of Actor: r0***************--
--************************************************--
node r0(clock, e5 :int) returns (nextClock, e11_P, e5_C :int; r0nbrFired: int );

var
e11_PD :int;
let
r0nbrFired= if r0DoFire(e5,3) then 3
		else if r0DoFire(e5,2) then 2
		else if r0DoFire(e5,1) then 1
		else 0;

(e5_C, e11_PD) = ((r0nbrFired * r0_e5_rate_in),(r0nbrFired * r0_e11_rate_out));

e11_P = 0 -> pre e11_PD;

nextClock = if (r0nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorr0-----------------
node r0DoFire(e5,times:int) returns ( yes: bool);
let

yes = if (e5>=  (times * r0_e5_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: sink1***************--
--************************************************--
node sink1(clock, e13 :int) returns (nextClock, e13_C, e15_P :int; sink1nbrFired: int );

var
e15_PD :int;
stage :int;
let
sink1nbrFired= if sink1DoFire(e13,1) then 1
		else 0;

(e13_C, e15_PD) = ((sink1nbrFired * sink1_e13_rate_in),(sink1nbrFired * sink1_e15_rate_out));

stage = if (sink1nbrFired = 0) then 0 
         else   1 ;

(nextClock , e15_P)=sink1Stage(clock, stage, 1, e15_PD); 

tel;
------------------subnode Dofire of Actorsink1-----------------
node sink1DoFire(e13,times:int) returns ( yes: bool);
let

yes = if (e13>=  (times * sink1_e13_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of Actorsink1-----------------
node sink1Stage(clock,  stage, numStage, e15_PD: int) returns (rTime, e15_P : int);

var 
e15_PDBuffer: int; 
selected, endExecution, active : bool; 

 let 
selected = if  (stage = numStage) then true else false ; 
 endExecution= false -> if not pre (active)  then false else pre  ((rTime - clock) = 0); 
active = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre active; 
rTime = if  selected then sink1_duration  else maxDuration -> 
          if  selected then sink1_duration 
          else if  (pre active) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 
(e15_PDBuffer) = if selected then (e15_PD) 
                               else (0) 
 ->if selected then (e15_PD) 
                               else if endExecution then (0)
           else pre (e15_PDBuffer); 
(e15_P) = (0) ->   if endExecution then pre (e15_PDBuffer)
                                        else (0); 
tel; 


--************************************************--
--******* Translation of Actor: sink2***************--
--************************************************--
node sink2(clock, e14 :int) returns (nextClock, e14_C, e16_P :int; sink2nbrFired: int );

var
e16_PD :int;
stage :int;
let
sink2nbrFired= if sink2DoFire(e14,1) then 1
		else 0;

(e14_C, e16_PD) = ((sink2nbrFired * sink2_e14_rate_in),(sink2nbrFired * sink2_e16_rate_out));

stage = if (sink2nbrFired = 0) then 0 
         else   1 ;

(nextClock , e16_P)=sink2Stage(clock, stage, 1, e16_PD); 

tel;
------------------subnode Dofire of Actorsink2-----------------
node sink2DoFire(e14,times:int) returns ( yes: bool);
let

yes = if (e14>=  (times * sink2_e14_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of Actorsink2-----------------
node sink2Stage(clock,  stage, numStage, e16_PD: int) returns (rTime, e16_P : int);

var 
e16_PDBuffer: int; 
selected, endExecution, active : bool; 

 let 
selected = if  (stage = numStage) then true else false ; 
 endExecution= false -> if not pre (active)  then false else pre  ((rTime - clock) = 0); 
active = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre active; 
rTime = if  selected then sink2_duration  else maxDuration -> 
          if  selected then sink2_duration 
          else if  (pre active) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 
(e16_PDBuffer) = if selected then (e16_PD) 
                               else (0) 
 ->if selected then (e16_PD) 
                               else if endExecution then (0)
           else pre (e16_PDBuffer); 
(e16_P) = (0) ->   if endExecution then pre (e16_PDBuffer)
                                        else (0); 
tel; 

--******* Node Min***************--
node Min (x, y :int) returns ( r: int);
let
r= if  (x < y) then x else y;
tel;

--************************************************--
--******* Node Top***************--
--************************************************--
node top (_: bool) returns ( clock, e1, e8, e2, e12, e3, e6, e7, e4, e9, e10, e11, e5, e13, e14, e15, e16, rinbrFired, m1nbrFired, m2nbrFired, a1nbrFired, a2nbrFired, r0nbrFired, sink1nbrFired, sink2nbrFired:int);

var

e1_C, e1_P: int; 
e8_C, e8_P: int; 
e2_C, e2_P: int; 
e12_C, e12_P: int; 
e3_C, e3_P: int; 
e6_C, e6_P: int; 
e7_C, e7_P: int; 
e4_C, e4_P: int; 
e9_C, e9_P: int; 
e10_C, e10_P: int; 
e11_C, e11_P: int; 
e5_C, e5_P: int; 
e13_C, e13_P: int; 
e14_C, e14_P: int; 
e15_P : int;
e16_P : int;
rinextClock : int;  
m1nextClock : int;  
m2nextClock : int;  
a1nextClock : int;  
a2nextClock : int;  
r0nextClock : int;  
sink1nextClock : int;  
sink2nextClock : int;  
positiveValues, P1, P2, P3, P4: bool; 

let

e1 = e1_I ->  ( pre ( e1 - e1_C) + e1_P);
e8 = e8_I ->  ( pre ( e8 - e8_C) + e8_P);
e2 = e2_I ->  ( pre ( e2 - e2_C) + e2_P);
e12 = e12_I ->  ( pre ( e12 - e12_C) + e12_P);
e3 = e3_I ->  ( pre ( e3 - e3_C) + e3_P);
e6 = e6_I ->  ( pre ( e6 - e6_C) + e6_P);
e7 = e7_I ->  ( pre ( e7 - e7_C) + e7_P);
e4 = e4_I ->  ( pre ( e4 - e4_C) + e4_P);
e9 = e9_I ->  ( pre ( e9 - e9_C) + e9_P);
e10 = e10_I ->  ( pre ( e10 - e10_C) + e10_P);
e11 = e11_I ->  ( pre ( e11 - e11_C) + e11_P);
e5 = e5_I ->  ( pre ( e5 - e5_C) + e5_P);
e13 = e13_I ->  ( pre ( e13 - e13_C) + e13_P);
e14 = e14_I ->  ( pre ( e14 - e14_C) + e14_P);



e15 = e15_I -> pre (e15+ e15_P);
e16 = e16_I -> pre (e16+ e16_P);

(rinextClock, e1_P, e8_C, e13_P, e14_P, rinbrFired) = ri(clock, e8);
(m1nextClock, e8_P, e1_C, e2_P, e12_C, e7_P, e4_C, m1nbrFired) = m1(clock, e1, e12, e4);
(m2nextClock, e2_C, e12_P, e3_P, e6_C, m2nbrFired) = m2(clock, e2, e6);
(a1nextClock, e3_C, e7_C, e4_P, e9_C, e10_P, a1nbrFired) = a1(clock, e3, e7, e9);
(a2nextClock, e6_P, e10_C, e9_P, e11_C, e5_P, a2nbrFired) = a2(clock, e10, e11);
(r0nextClock, e11_P, e5_C, r0nbrFired) = r0(clock, e5);
(sink1nextClock, e13_C, e15_P, sink1nbrFired) = sink1(clock, e13);
(sink2nextClock, e14_C, e16_P, sink2nbrFired) = sink2(clock, e14);

clock= Min(rinextClock , Min(m1nextClock , Min(m2nextClock , Min(a1nextClock , Min(a2nextClock , Min(r0nextClock , Min(sink1nextClock , sink2nextClock)))))));



positiveValues = ( e1 >= 0) 
	and ( e8 >= 0) 
	and ( e2 >= 0) 
	and ( e12 >= 0) 
	and ( e3 >= 0) 
	and ( e6 >= 0) 
	and ( e7 >= 0) 
	and ( e4 >= 0) 
	and ( e9 >= 0) 
	and ( e10 >= 0) 
	and ( e11 >= 0) 
	and ( e5 >= 0) 
	and ( e13 >= 0) 
	and ( e14 >= 0) 
	and ( e15>= 0) 
	and ( e16>= 0) 
	and ( rinbrFired  >=  0) 
	and ( m1nbrFired  >=  0) 
	and ( m2nbrFired  >=  0) 
	and ( a1nbrFired  >=  0) 
	and ( a2nbrFired  >=  0) 
	and ( r0nbrFired  >=  0) 
	and ( sink1nbrFired  >=  0) 
	and ( sink2nbrFired  >=  0) ;
 

 
P1= ( rinbrFired <=1) 
	and  ( m1nbrFired <=1) 
	and  ( m2nbrFired <=1) 
	and  ( a1nbrFired <=1) 
	and  ( a2nbrFired <=1) 
	and  ( r0nbrFired <=1);
P2= (m1nbrFired >= 1 => a2nbrFired >= 1 ) and (a2nbrFired >= 1 => m1nbrFired >= 1 ) ;
P3= (m2nbrFired >= 1 => a1nbrFired =0 ) and (a1nbrFired >= 1 => m2nbrFired =0 ) ;

---L1= 23, L2=25
 P4= r0nbrFired >= 1 =>   (e15_P >=1   or e16_P >=1);

--%MAIN;

--%PROPERTY  "Ok, all variables are positive "  positiveValues;
--%PROPERTY  "P1"  P1;
--%PROPERTY  "P2"  P2;
--%PROPERTY  "P3"  P3;
--%PROPERTY  "P4"  P4;

tel;


