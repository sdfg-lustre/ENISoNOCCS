--** This lustre code is generated automatically on 28 aoÃ»t 2020 10:27:10 AM
--** It corresponds to the translation of an SDFG model (Memory Access)  to Lustre. This version produce a Lustre code having a reduced number of steps.




--**************** Const Rates ****************--

const ri_e1_rate_out = 3;
const ri_e8_rate_in = 3;
const ri_e13_rate_out = 1;
const ri_e14_rate_out = 1;
const m1_e8_rate_out = 1;
const m1_e1_rate_in = 1;
const m1_e2_rate_out = 1;
const m1_e12_rate_in = 1;
const m1_e7_rate_out = 1;
const m1_e4_rate_in = 1;
const m2_e2_rate_in = 1;
const m2_e12_rate_out = 1;
const m2_e3_rate_out = 1;
const m2_e6_rate_in = 1;
const a1_e3_rate_in = 1;
const a1_e7_rate_in = 1;
const a1_e4_rate_out = 1;
const a1_e9_rate_in = 1;
const a1_e10_rate_out = 1;
const a2_e6_rate_out = 1;
const a2_e10_rate_in = 1;
const a2_e9_rate_out = 1;
const a2_e11_rate_in = 1;
const a2_e5_rate_out = 1;
const r0_e11_rate_out = 3;
const r0_e5_rate_in = 3;
const sink1_e13_rate_in = 1;
const sink1_e15_rate_out = 1;
const sink2_e14_rate_in = 1;
const sink2_e16_rate_out = 1;

--****************  Actors' durations ****************--

const ri_maxStages  = 1;
const ri_duration  = 1;
const m1_maxStages  = 1;
const m1_duration  = 4;
const m2_maxStages  = 1;
const m2_duration  = 2;
const a1_maxStages  = 1;
const a1_duration  = 3;
const a2_maxStages  = 1;
const a2_duration  = 2;
const r0_maxStages  = 1;
const r0_duration  = 1;
const sink1_maxStages  = 1;
const sink1_duration  = 23;
const sink2_maxStages  = 1;
const sink2_duration  = 25;
const  maxDuration  = 25;

--**************** Init Channel ****************--

const e1_I = 0;
const e8_I = 3;
const e2_I = 0;
const e12_I = 1;
const e3_I = 1;
const e6_I = 0;
const e7_I = 1;
const e4_I = 0;
const e9_I = 1;
const e10_I = 0;
const e11_I = 3;
const e5_I = 0;
const e13_I = 0;
const e14_I = 0;

const e15_I = 0;
const e16_I = 0;

--************************************************--
--******* Translation of Actor: ri***************--
--************************************************--
node ri(clock, e8 :int) returns (nextClock, e1_P, e8_C, e13_P, e14_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if riDoFire(e8,3) then 3
		else if riDoFire(e8,2) then 2
		else if riDoFire(e8,1) then 1
		else 0;

(e8_C) = ((nbrFired * ri_e8_rate_in));

nbrEnd = 0 -> pre nbrFired  ;
(e1_P, e13_P, e14_P) = ((nbrEnd * ri_e1_rate_out), (nbrEnd * ri_e13_rate_out), (nbrEnd * ri_e14_rate_out));

nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorri-----------------
node riDoFire(e8,times:int) returns ( yes: bool);
let

yes = if (e8>=  (times * ri_e8_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: m1***************--
--************************************************--
node m1(clock, e1, e12, e4 :int) returns (nextClock, e8_P, e1_C, e2_P, e12_C, e7_P, e4_C :int; nbrFired, nbrEnd: int );

var
stage :int;
let
nbrFired= if m1DoFire(e1, e12, e4,3) then 3
		else if m1DoFire(e1, e12, e4,2) then 2
		else if m1DoFire(e1, e12, e4,1) then 1
		else 0;

(e1_C, e12_C, e4_C) = ((nbrFired * m1_e1_rate_in), (nbrFired * m1_e12_rate_in), (nbrFired * m1_e4_rate_in));

stage = if (nbrFired = 0) then 0 
         else   1 ;

(nextClock, nbrEnd) = m1Stage (clock, stage, 1, nbrFired ); 
(e8_P, e2_P, e7_P) = ((nbrEnd * m1_e8_rate_out), (nbrEnd * m1_e2_rate_out), (nbrEnd * m1_e7_rate_out));

tel;
------------------subnode Dofire of Actorm1-----------------
node m1DoFire(e1, e12, e4,times:int) returns ( yes: bool);
let

yes = if (e1>=  (times * m1_e1_rate_in)) 
	and (e12>=  (times * m1_e12_rate_in)) 
	and (e4>=  (times * m1_e4_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of Actorm1-----------------
node m1Stage(clock,  stage, numStage, nbrFired : int) returns (rTime, nbrEnd : int);

var 
nbrFiredBuf : int; 
selected, endExecution, running : bool; 

 let
 selected = if  (stage = numStage) then true else false ; 
 
 endExecution= false -> if not pre (running)  then false else pre  ((rTime - clock) = 0); 

 running = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre running; 

 nbrFiredBuf = if selected then nbrFired  else 0 -> 
                        if selected then  nbrFired  else if endExecution then 0 else pre nbrFiredBuf ; 

 nbrEnd = 0 -> if endExecution then pre nbrFiredBuf else 0; 

 rTime = if  selected then m1_duration  else maxDuration -> 
          if  selected then m1_duration 
          else if  (pre running) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 

 tel; 


--************************************************--
--******* Translation of Actor: m2***************--
--************************************************--
node m2(clock, e2, e6 :int) returns (nextClock, e2_C, e12_P, e3_P, e6_C :int; nbrFired, nbrEnd: int );

var
stage :int;
let
nbrFired= if m2DoFire(e2, e6,3) then 3
		else if m2DoFire(e2, e6,2) then 2
		else if m2DoFire(e2, e6,1) then 1
		else 0;

(e2_C, e6_C) = ((nbrFired * m2_e2_rate_in), (nbrFired * m2_e6_rate_in));

stage = if (nbrFired = 0) then 0 
         else   1 ;

(nextClock, nbrEnd) = m2Stage (clock, stage, 1, nbrFired ); 
(e12_P, e3_P) = ((nbrEnd * m2_e12_rate_out), (nbrEnd * m2_e3_rate_out));

tel;
------------------subnode Dofire of Actorm2-----------------
node m2DoFire(e2, e6,times:int) returns ( yes: bool);
let

yes = if (e2>=  (times * m2_e2_rate_in)) 
	and (e6>=  (times * m2_e6_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of Actorm2-----------------
node m2Stage(clock,  stage, numStage, nbrFired : int) returns (rTime, nbrEnd : int);

var 
nbrFiredBuf : int; 
selected, endExecution, running : bool; 

 let
 selected = if  (stage = numStage) then true else false ; 
 
 endExecution= false -> if not pre (running)  then false else pre  ((rTime - clock) = 0); 

 running = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre running; 

 nbrFiredBuf = if selected then nbrFired  else 0 -> 
                        if selected then  nbrFired  else if endExecution then 0 else pre nbrFiredBuf ; 

 nbrEnd = 0 -> if endExecution then pre nbrFiredBuf else 0; 

 rTime = if  selected then m2_duration  else maxDuration -> 
          if  selected then m2_duration 
          else if  (pre running) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 

 tel; 


--************************************************--
--******* Translation of Actor: a1***************--
--************************************************--
node a1(clock, e3, e7, e9 :int) returns (nextClock, e3_C, e7_C, e4_P, e9_C, e10_P :int; nbrFired, nbrEnd: int );

var
stage :int;
let
nbrFired= if a1DoFire(e3, e7, e9,3) then 3
		else if a1DoFire(e3, e7, e9,2) then 2
		else if a1DoFire(e3, e7, e9,1) then 1
		else 0;

(e3_C, e7_C, e9_C) = ((nbrFired * a1_e3_rate_in), (nbrFired * a1_e7_rate_in), (nbrFired * a1_e9_rate_in));

stage = if (nbrFired = 0) then 0 
         else   1 ;

(nextClock, nbrEnd) = a1Stage (clock, stage, 1, nbrFired ); 
(e4_P, e10_P) = ((nbrEnd * a1_e4_rate_out), (nbrEnd * a1_e10_rate_out));

tel;
------------------subnode Dofire of Actora1-----------------
node a1DoFire(e3, e7, e9,times:int) returns ( yes: bool);
let

yes = if (e3>=  (times * a1_e3_rate_in)) 
	and (e7>=  (times * a1_e7_rate_in)) 
	and (e9>=  (times * a1_e9_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of Actora1-----------------
node a1Stage(clock,  stage, numStage, nbrFired : int) returns (rTime, nbrEnd : int);

var 
nbrFiredBuf : int; 
selected, endExecution, running : bool; 

 let
 selected = if  (stage = numStage) then true else false ; 
 
 endExecution= false -> if not pre (running)  then false else pre  ((rTime - clock) = 0); 

 running = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre running; 

 nbrFiredBuf = if selected then nbrFired  else 0 -> 
                        if selected then  nbrFired  else if endExecution then 0 else pre nbrFiredBuf ; 

 nbrEnd = 0 -> if endExecution then pre nbrFiredBuf else 0; 

 rTime = if  selected then a1_duration  else maxDuration -> 
          if  selected then a1_duration 
          else if  (pre running) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 

 tel; 


--************************************************--
--******* Translation of Actor: a2***************--
--************************************************--
node a2(clock, e10, e11 :int) returns (nextClock, e6_P, e10_C, e9_P, e11_C, e5_P :int; nbrFired, nbrEnd: int );

var
stage :int;
let
nbrFired= if a2DoFire(e10, e11,3) then 3
		else if a2DoFire(e10, e11,2) then 2
		else if a2DoFire(e10, e11,1) then 1
		else 0;

(e10_C, e11_C) = ((nbrFired * a2_e10_rate_in), (nbrFired * a2_e11_rate_in));

stage = if (nbrFired = 0) then 0 
         else   1 ;

(nextClock, nbrEnd) = a2Stage (clock, stage, 1, nbrFired ); 
(e6_P, e9_P, e5_P) = ((nbrEnd * a2_e6_rate_out), (nbrEnd * a2_e9_rate_out), (nbrEnd * a2_e5_rate_out));

tel;
------------------subnode Dofire of Actora2-----------------
node a2DoFire(e10, e11,times:int) returns ( yes: bool);
let

yes = if (e10>=  (times * a2_e10_rate_in)) 
	and (e11>=  (times * a2_e11_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of Actora2-----------------
node a2Stage(clock,  stage, numStage, nbrFired : int) returns (rTime, nbrEnd : int);

var 
nbrFiredBuf : int; 
selected, endExecution, running : bool; 

 let
 selected = if  (stage = numStage) then true else false ; 
 
 endExecution= false -> if not pre (running)  then false else pre  ((rTime - clock) = 0); 

 running = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre running; 

 nbrFiredBuf = if selected then nbrFired  else 0 -> 
                        if selected then  nbrFired  else if endExecution then 0 else pre nbrFiredBuf ; 

 nbrEnd = 0 -> if endExecution then pre nbrFiredBuf else 0; 

 rTime = if  selected then a2_duration  else maxDuration -> 
          if  selected then a2_duration 
          else if  (pre running) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 

 tel; 


--************************************************--
--******* Translation of Actor: r0***************--
--************************************************--
node r0(clock, e5 :int) returns (nextClock, e11_P, e5_C :int; nbrFired, nbrEnd: int );

let
nbrFired= if r0DoFire(e5,3) then 3
		else if r0DoFire(e5,2) then 2
		else if r0DoFire(e5,1) then 1
		else 0;

(e5_C) = ((nbrFired * r0_e5_rate_in));

nbrEnd = 0 -> pre nbrFired  ;
(e11_P) = ((nbrEnd * r0_e11_rate_out));

nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorr0-----------------
node r0DoFire(e5,times:int) returns ( yes: bool);
let

yes = if (e5>=  (times * r0_e5_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: sink1***************--
--************************************************--
node sink1(clock, e13 :int) returns (nextClock, e13_C, e15_P :int; nbrFired, nbrEnd: int );

var
stage :int;
let
nbrFired= if sink1DoFire(e13,1) then 1
		else 0;

(e13_C) = ((nbrFired * sink1_e13_rate_in));

stage = if (nbrFired = 0) then 0 
         else   1 ;

(nextClock, nbrEnd) = sink1Stage (clock, stage, 1, nbrFired ); 
(e15_P) = ((nbrEnd * sink1_e15_rate_out));

tel;
------------------subnode Dofire of Actorsink1-----------------
node sink1DoFire(e13,times:int) returns ( yes: bool);
let

yes = if (e13>=  (times * sink1_e13_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of Actorsink1-----------------
node sink1Stage(clock,  stage, numStage, nbrFired : int) returns (rTime, nbrEnd : int);

var 
nbrFiredBuf : int; 
selected, endExecution, running : bool; 

 let
 selected = if  (stage = numStage) then true else false ; 
 
 endExecution= false -> if not pre (running)  then false else pre  ((rTime - clock) = 0); 

 running = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre running; 

 nbrFiredBuf = if selected then nbrFired  else 0 -> 
                        if selected then  nbrFired  else if endExecution then 0 else pre nbrFiredBuf ; 

 nbrEnd = 0 -> if endExecution then pre nbrFiredBuf else 0; 

 rTime = if  selected then sink1_duration  else maxDuration -> 
          if  selected then sink1_duration 
          else if  (pre running) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 

 tel; 


--************************************************--
--******* Translation of Actor: sink2***************--
--************************************************--
node sink2(clock, e14 :int) returns (nextClock, e14_C, e16_P :int; nbrFired, nbrEnd: int );

var
stage :int;
let
nbrFired= if sink2DoFire(e14,1) then 1
		else 0;

(e14_C) = ((nbrFired * sink2_e14_rate_in));

stage = if (nbrFired = 0) then 0 
         else   1 ;

(nextClock, nbrEnd) = sink2Stage (clock, stage, 1, nbrFired ); 
(e16_P) = ((nbrEnd * sink2_e16_rate_out));

tel;
------------------subnode Dofire of Actorsink2-----------------
node sink2DoFire(e14,times:int) returns ( yes: bool);
let

yes = if (e14>=  (times * sink2_e14_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of Actorsink2-----------------
node sink2Stage(clock,  stage, numStage, nbrFired : int) returns (rTime, nbrEnd : int);

var 
nbrFiredBuf : int; 
selected, endExecution, running : bool; 

 let
 selected = if  (stage = numStage) then true else false ; 
 
 endExecution= false -> if not pre (running)  then false else pre  ((rTime - clock) = 0); 

 running = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre running; 

 nbrFiredBuf = if selected then nbrFired  else 0 -> 
                        if selected then  nbrFired  else if endExecution then 0 else pre nbrFiredBuf ; 

 nbrEnd = 0 -> if endExecution then pre nbrFiredBuf else 0; 

 rTime = if  selected then sink2_duration  else maxDuration -> 
          if  selected then sink2_duration 
          else if  (pre running) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 

 tel; 

--******* Node Min***************--
node Min (x, y :int) returns ( r: int);
let
r= if  (x < y) then x else y;
tel;

--************************************************--
--******* Node Top***************--
--************************************************--
node top (_: bool) returns ( clock, e1, e8, e2, e12, e3, e6, e7, e4, e9, e10, e11, e5, e13, e14, e15, e16, rinbrFired, m1nbrFired, m2nbrFired, a1nbrFired, a2nbrFired, r0nbrFired, sink1nbrFired, sink2nbrFired:int);

var

e1_C, e1_P: int; 
e8_C, e8_P: int; 
e2_C, e2_P: int; 
e12_C, e12_P: int; 
e3_C, e3_P: int; 
e6_C, e6_P: int; 
e7_C, e7_P: int; 
e4_C, e4_P: int; 
e9_C, e9_P: int; 
e10_C, e10_P: int; 
e11_C, e11_P: int; 
e5_C, e5_P: int; 
e13_C, e13_P: int; 
e14_C, e14_P: int; 
e15_P : int;
e16_P : int;
rinextClock : int;  
m1nextClock : int;  
m2nextClock : int;  
a1nextClock : int;  
a2nextClock : int;  
r0nextClock : int;  
sink1nextClock : int;  
sink2nextClock : int;  
rinbrEnd, m1nbrEnd, m2nbrEnd, a1nbrEnd, a2nbrEnd, r0nbrEnd, sink1nbrEnd, sink2nbrEnd : int; 

 

positiveValues, P1, P2, P3, P4: bool; 

let

e1 = e1_I ->  ( pre ( e1 - e1_C) + e1_P);
e8 = e8_I ->  ( pre ( e8 - e8_C) + e8_P);
e2 = e2_I ->  ( pre ( e2 - e2_C) + e2_P);
e12 = e12_I ->  ( pre ( e12 - e12_C) + e12_P);
e3 = e3_I ->  ( pre ( e3 - e3_C) + e3_P);
e6 = e6_I ->  ( pre ( e6 - e6_C) + e6_P);
e7 = e7_I ->  ( pre ( e7 - e7_C) + e7_P);
e4 = e4_I ->  ( pre ( e4 - e4_C) + e4_P);
e9 = e9_I ->  ( pre ( e9 - e9_C) + e9_P);
e10 = e10_I ->  ( pre ( e10 - e10_C) + e10_P);
e11 = e11_I ->  ( pre ( e11 - e11_C) + e11_P);
e5 = e5_I ->  ( pre ( e5 - e5_C) + e5_P);
e13 = e13_I ->  ( pre ( e13 - e13_C) + e13_P);
e14 = e14_I ->  ( pre ( e14 - e14_C) + e14_P);



e15 = e15_I -> pre (e15+ e15_P);
e16 = e16_I -> pre (e16+ e16_P);

(rinextClock, e1_P, e8_C, e13_P, e14_P, rinbrFired, rinbrEnd ) = ri(clock, e8);
(m1nextClock, e8_P, e1_C, e2_P, e12_C, e7_P, e4_C, m1nbrFired, m1nbrEnd ) = m1(clock, e1, e12, e4);
(m2nextClock, e2_C, e12_P, e3_P, e6_C, m2nbrFired, m2nbrEnd ) = m2(clock, e2, e6);
(a1nextClock, e3_C, e7_C, e4_P, e9_C, e10_P, a1nbrFired, a1nbrEnd ) = a1(clock, e3, e7, e9);
(a2nextClock, e6_P, e10_C, e9_P, e11_C, e5_P, a2nbrFired, a2nbrEnd ) = a2(clock, e10, e11);
(r0nextClock, e11_P, e5_C, r0nbrFired, r0nbrEnd ) = r0(clock, e5);
(sink1nextClock, e13_C, e15_P, sink1nbrFired, sink1nbrEnd ) = sink1(clock, e13);
(sink2nextClock, e14_C, e16_P, sink2nbrFired, sink2nbrEnd ) = sink2(clock, e14);

clock= Min(rinextClock , Min(m1nextClock , Min(m2nextClock , Min(a1nextClock , Min(a2nextClock , Min(r0nextClock , Min(sink1nextClock , sink2nextClock)))))));

 

positiveValues = ( e1 >= 0) 
	and ( e8 >= 0) 
	and ( e2 >= 0) 
	and ( e12 >= 0) 
	and ( e3 >= 0) 
	and ( e6 >= 0) 
	and ( e7 >= 0) 
	and ( e4 >= 0) 
	and ( e9 >= 0) 
	and ( e10 >= 0) 
	and ( e11 >= 0) 
	and ( e5 >= 0) 
	and ( e13 >= 0) 
	and ( e14 >= 0) 
	and ( e15>= 0) 
	and ( e16>= 0) 
	and ( rinbrFired  >=  0) 
	and ( m1nbrFired  >=  0) 
	and ( m2nbrFired  >=  0) 
	and ( a1nbrFired  >=  0) 
	and ( a2nbrFired  >=  0) 
	and ( r0nbrFired  >=  0) 
	and ( sink1nbrFired  >=  0) 
	and ( sink2nbrFired  >=  0) ;
--%MAIN;

--%PROPERTY  "Ok, all variables are positive "  positiveValues;

P1= ( rinbrFired <=1) 
	and  ( m1nbrFired <=1) 
	and  ( m2nbrFired <=1) 
	and  ( a1nbrFired <=1) 
	and  ( a2nbrFired <=1) 
	and  ( r0nbrFired <=1);
P2= (m1nbrFired >= 1 => a2nbrFired >= 1 ) and (a2nbrFired >= 1 => m1nbrFired >= 1 ) ;
P3= (m2nbrFired >= 1 => a1nbrFired =0 ) and (a1nbrFired >= 1 => m2nbrFired =0 ) ;

---L1= 23, L2=25
 P4= r0nbrEnd >= 1 =>  sink1nbrEnd >=1   or sink2nbrEnd>=1;

--%MAIN;

--%PROPERTY  "Ok, all variables are positive "  positiveValues;
--%PROPERTY  "P1"  P1;
--%PROPERTY  "P2"  P2;
--%PROPERTY  "P3"  P3;
--%PROPERTY  "P4"  P4;
tel;
tel;


