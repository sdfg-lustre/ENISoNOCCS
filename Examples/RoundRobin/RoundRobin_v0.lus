include "../BitBlasting/toInclude_BitBlasting_ok.lus"



--------------instruction with --------------------
--node P(const n: int; B: bool^n) returns (p:bool);
--let
-- p = with n=1 then B[0]
--      else XOR(B[n-1] , P(n-1,B[0..n-2]));
--tel



------------------------------SDFG weights
const IN_X=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];	const OUT_X=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; const X0=[0 , 0 , 0 , 0,  0 , 0  ,0  ,0]; 
const IN_Y=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];	const OUT_Y=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; const Y0=[0 , 0 , 0 , 0,  0 , 0  ,0  ,0];
const IN_Z=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];	const OUT_Z=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; const Z0=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];
const IN_V=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];	const OUT_V=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; const V0=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];
const IN_W=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];	const OUT_W=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; const W0=[1 , 1 , 0 , 0,  0 , 0  ,0  ,0];
const IN_A=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];
const IN_B=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];     const OUT_B=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; const B0=[1, 1,  0 , 0,  0 , 0  ,0  ,0];


--*******************node Tw*****************************************************
node Tw (A, B: UsrInt) returns (consB, prodY : UsrInt;  TwFired: bool);
let

TwFired =UsrIntGte (A, IN_A) and UsrIntGte (B, IN_B);

(consB, prodY) =	if 	DoFireTw (A,B,UsrInt_4) then FireTw (UsrInt_4) 
			else if DoFireTw (A,B,UsrInt_3) then FireTw (UsrInt_3) 
			else if DoFireTw (A,B,UsrInt_2) then FireTw (UsrInt_2)  
			else if DoFireTw (A,B,UsrInt_1) then FireTw (UsrInt_1) 
			else 					FireTw (UsrInt_0);
tel

----------
node FireTw (times:UsrInt) returns (consB,  prodY: UsrInt);
let
consB= FourBitsMult(times, IN_B) ;
prodY= FourBitsMult(times, OUT_Y);
tel

----------
node DoFireTw (A, B, times:UsrInt) returns ( yes: bool);
let
yes = if UsrIntGte (A, FourBitsMult(times, IN_A)) and 
	 UsrIntGte (B, FourBitsMult(times, IN_B)) then true 
	else false;
tel
---



--*****************node Ta*******************************************************
 node Ta (Y: UsrInt) returns (consY,  prodB, prodX :UsrInt;  TaFired:bool);
let

TaFired = UsrIntGte (Y, IN_Y) ;
(consY, prodB, prodX) =	if 	DoFireTa ( Y, UsrInt_4)  then FireTa (UsrInt_4) 
				else if DoFireTa (Y, UsrInt_3) then FireTa (UsrInt_3) 
				else if DoFireTa (Y, UsrInt_2) then FireTa (UsrInt_2)  
				else if DoFireTa (Y, UsrInt_1) then FireTa (UsrInt_1) 
				else 					FireTa (UsrInt_0);
tel

----
node DoFireTa (Y, times:UsrInt) returns ( yes: bool);
let
yes = if  UsrIntGte (Y, FourBitsMult(times, IN_Y)) then true 
	else false;
tel
---

node FireTa (times:UsrInt) returns (consY, prodB, prodX: UsrInt);
let

consY= FourBitsMult(times, IN_Y);

prodB= FourBitsMult(times,OUT_B) ;
prodX= FourBitsMult(times,OUT_X) ;
tel
----

--********************RR_model1****************************************************
node RR_model1 (A:UsrInt) returns (  X: UsrInt; TwFired, TaFired : bool);
 var  prodY, consY, delayedY  , prodB, consB, delayedB, prodX, delayedX, X1, 
Y, B,  Y1,  B1: UsrInt;

let

(consB, delayedY,  TwFired) =  Tw (A,B);
 prodY= UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre delayedY)))))))))));


(consY,  delayedB, delayedX, TaFired)= Ta(Y);
 prodB= UsrInt_0->(pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre  delayedB)))))));
prodX= UsrInt_0->(pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre  delayedX)))))));
 
Y1= UsrIntPlus (UsrIntMinus (Y, consY), prodY);		Y= Y0-> (pre Y1);
B1= UsrIntPlus (UsrIntMinus (B, consB), prodB);   	B= B0-> (pre B1);
X1= UsrIntPlus (X,  prodX);   X= X0-> (pre X1);
tel


-----------------------------RR_Model2-------------------------------------------

--*****************node TaBis*******************************************************
 node TaBis (Z, W: UsrInt) returns (consW, prodW, prodX:UsrInt;  TaBisFired:bool);
let

TaBisFired =UsrIntGte (Z, IN_Z) and  UsrIntGte (W, IN_W);
(consW, prodW, prodX) =	if 	DoFireTaBis (Z,   W, UsrInt_4)  then FireTaBis (UsrInt_4) 
				else if DoFireTaBis (Z,   W, UsrInt_3) then FireTaBis (UsrInt_3) 
				else if DoFireTaBis (Z,   W, UsrInt_2) then FireTaBis (UsrInt_2)  
				else if DoFireTaBis (Z,   W, UsrInt_1) then FireTaBis (UsrInt_1) 
				else 					FireTaBis (UsrInt_0);
tel
----
node DoFireTaBis (Z,  W, times:UsrInt) returns ( yes: bool);
let
yes = if UsrIntGte (Z, FourBitsMult(times, IN_Z)) and 
	  	 UsrIntGte (W, FourBitsMult(times, IN_W)) then true 
	else false;
tel
---
node FireTaBis (times:UsrInt) returns ( consW, prodW, prodX: UsrInt);
let
consW= FourBitsMult(times, IN_W);
prodW= FourBitsMult(times,OUT_W) ;
prodX= FourBitsMult(times,OUT_X) ;
tel


node RR_model2 (Z:UsrInt) returns ( X: UsrInt; TaBisFired: bool);
--------------
var       prodW,   consW, delayedW,   W,    W1, prodX, delayedX, X1: UsrInt;

let

(consW, delayedW, delayedX,  TaBisFired)= TaBis(Z,W);

prodW= UsrInt_0->(pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre delayedW)))))))))))))))))))));
prodX= UsrInt_0->(pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre delayedX)))))))))))))))))))));
 

 W1= UsrIntPlus (UsrIntMinus (W, consW), prodW);   W= W0-> (pre W1);
 X1= UsrIntPlus (X,  prodX);   X= X0-> (pre X1);
tel


--*************************Top***********************
node top (A:UsrInt) returns ( same: bool; X1, X2: UsrInt);
var  TaFired, TaBisFired, TwFired: bool;
let 
(X1, TwFired, TaFired)= RR_model1(A);
(X2, TaBisFired) = RR_model2(A);

same= if UsrIntEq (X1, X2) then true else false;
tel 
