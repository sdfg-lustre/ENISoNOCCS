--** This lustre code is generated automatically on 12 sept. 2020 03:44:42 PM
--** It corresponds to the translation of an SDFG model (MP3 )  to Lustre. This version produce a Lustre code having a reduced number of steps.




--**************** Const Rates ****************--

const MP3_e1in_rate_in = 1;
const MP3_e1out_rate_out = 1;
const MP3_e2_rate_in = 470;
const MP3_e3_rate_out = 470;
const src_e4in_rate_in = 1;
const src_e4out_rate_out = 1;
const src_e3_rate_in = 6;
const src_e8_rate_in = 8;
const src_e2_rate_out = 6;
const src_e9_rate_out = 8;
const dac_e10in_rate_in = 1;
const dac_e10out_rate_out = 1;
const dac_e9_rate_in = 1;
const dac_e8_rate_out = 1;

--****************  Actors' durations ****************--

const MP3_maxStages  = 1;
const MP3_duration  = 1;
const src_maxStages  = 1;
const src_duration  = 1;
const dac_maxStages  = 1;
const dac_duration  = 1;
const  maxDuration  = 1;

--**************** Init Channel ****************--

const e1_I = 1;
const e4_I = 1;
const e10_I = 1;
const e2_I = 520;
const e3_I = 0;
const e8_I = 190;
const e9_I = 0;


--************************************************--
--******* Translation of Actor: MP3***************--
--************************************************--
node MP3(clock, e1in, e2 :int) returns (nextClock, e1in_C, e1out_P, e2_C, e3_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if MP3DoFire(e1in, e2,1) then 1
		else 0;

(e1in_C, e2_C) = ((nbrFired * MP3_e1in_rate_in), (nbrFired * MP3_e2_rate_in));

(e1out_P, e3_P) = ((nbrEnd * MP3_e1out_rate_out), (nbrEnd * MP3_e3_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of ActorMP3-----------------
node MP3DoFire(e1in, e2,times:int) returns ( yes: bool);
let

yes = if (e1in>=  (times * MP3_e1in_rate_in)) 
	and (e2>=  (times * MP3_e2_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: src***************--
--************************************************--
node src(clock, e4in, e3, e8 :int) returns (nextClock, e4in_C, e4out_P, e3_C, e8_C, e2_P, e9_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if srcDoFire(e4in, e3, e8,1) then 1
		else 0;

(e4in_C, e3_C, e8_C) = ((nbrFired * src_e4in_rate_in), (nbrFired * src_e3_rate_in), (nbrFired * src_e8_rate_in));

(e4out_P, e2_P, e9_P) = ((nbrEnd * src_e4out_rate_out), (nbrEnd * src_e2_rate_out), (nbrEnd * src_e9_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorsrc-----------------
node srcDoFire(e4in, e3, e8,times:int) returns ( yes: bool);
let

yes = if (e4in>=  (times * src_e4in_rate_in)) 
	and (e3>=  (times * src_e3_rate_in)) 
	and (e8>=  (times * src_e8_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: dac***************--
--************************************************--
node dac(clock, e10in, e9 :int) returns (nextClock, e10in_C, e10out_P, e9_C, e8_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if dacDoFire(e10in, e9,1) then 1
		else 0;

(e10in_C, e9_C) = ((nbrFired * dac_e10in_rate_in), (nbrFired * dac_e9_rate_in));

(e10out_P, e8_P) = ((nbrEnd * dac_e10out_rate_out), (nbrEnd * dac_e8_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actordac-----------------
node dacDoFire(e10in, e9,times:int) returns ( yes: bool);
let

yes = if (e10in>=  (times * dac_e10in_rate_in)) 
	and (e9>=  (times * dac_e9_rate_in)) 
	then true 
	else false;

tel;
--******* Node Min***************--
node Min (x, y :int) returns ( r: int);
let
r= if  (x < y) then x else y;
tel;

--************************************************--
--******* Node Top***************--
--************************************************--
node top (_: bool) returns ( adv, e1, e4, e10, e2, e3, e8, e9, MP3nbrFired, srcnbrFired, dacnbrFired:int);

var

e1_C, e1_P: int; 
e4_C, e4_P: int; 
e10_C, e10_P: int; 
e2_C, e2_P: int; 
e3_C, e3_P: int; 
e8_C, e8_P: int; 
e9_C, e9_P: int; 
MP3nextClock : int;  
srcnextClock : int;  
dacnextClock : int;  
MP3nbrEnd, srcnbrEnd, dacnbrEnd : int; 

MP3nbrRun, srcnbrRun, dacnbrRun : int; 

positiveValues, noDeadlock: bool; 

let

e1 = e1_I ->  ( pre ( e1 - e1_C) + e1_P);
e4 = e4_I ->  ( pre ( e4 - e4_C) + e4_P);
e10 = e10_I ->  ( pre ( e10 - e10_C) + e10_P);
e2 = e2_I ->  ( pre ( e2 - e2_C) + e2_P);
e3 = e3_I ->  ( pre ( e3 - e3_C) + e3_P);
e8 = e8_I ->  ( pre ( e8 - e8_C) + e8_P);
e9 = e9_I ->  ( pre ( e9 - e9_C) + e9_P);




(MP3nextClock, e1_C, e1_P, e2_C, e3_P, MP3nbrFired, MP3nbrEnd ) = MP3(adv, e1, e2);
(srcnextClock, e4_C, e4_P, e3_C, e8_C, e2_P, e9_P, srcnbrFired, srcnbrEnd ) = src(adv, e4, e3, e8);
(dacnextClock, e10_C, e10_P, e9_C, e8_P, dacnbrFired, dacnbrEnd ) = dac(adv, e10, e9);

adv= Min(MP3nextClock , Min(srcnextClock , dacnextClock));


MP3nbrRun=  MP3nbrFired  -> (pre MP3nbrRun) +MP3nbrFired - MP3nbrEnd ;

srcnbrRun=  srcnbrFired  -> (pre srcnbrRun) +srcnbrFired - srcnbrEnd ;

dacnbrRun=  dacnbrFired  -> (pre dacnbrRun) +dacnbrFired - dacnbrEnd ;


positiveValues = ( e1 >= 0) 
	and ( e4 >= 0) 
	and ( e10 >= 0) 
	and ( e2 >= 0) 
	and ( e3 >= 0) 
	and ( e8 >= 0) 
	and ( e9 >= 0) 
	and ( MP3nbrFired  >=  0) 
	and ( srcnbrFired  >=  0) 
	and ( dacnbrFired  >=  0) ;

noDeadlock = ( MP3nbrRun >= 1) 
	or  ( srcnbrRun >= 1) 
	or  ( dacnbrRun >= 1);
--%MAIN;

--%PROPERTY  "Ok, all variables are positive "  positiveValues;

--%PROPERTY  "no deadlock "  noDeadlock;


tel;


