--** This lustre code is generated automatically on 12 sept. 2020 03:42:37 PM
--**It corresponds to a translation to Lustre of the Untimed SDFG model  of the design "MP3 " 




--**************** Const Rates ****************--

const MP3_e1in_rate_in = 1 ;
const MP3_e1out_rate_out = 1 ;
const MP3_e2_rate_in = 470 ;
const MP3_e3_rate_out = 470 ;
const src_e4in_rate_in = 1 ;
const src_e4out_rate_out = 1 ;
const src_e3_rate_in = 6 ;
const src_e8_rate_in = 8 ;
const src_e2_rate_out = 6 ;
const src_e9_rate_out = 8 ;
const dac_e10in_rate_in = 1 ;
const dac_e10out_rate_out = 1 ;
const dac_e9_rate_in = 1 ;
const dac_e8_rate_out = 1 ;

--**************** Init Channel ****************--

const e1_I = 1 ;
const e4_I = 1 ;
const e10_I = 1 ;
const e2_I = 520 ;
const e3_I = 0 ;
const e8_I = 190 ;
const e9_I = 0 ;


--**************** Nodes Declaration ****************--

node MP3(e1in, e2 :int) returns (e1in_C, e1out_P, e2_C, e3_P :int; MP3nbrFired: int );

var
MP3nbrEnd: int;
let
MP3nbrFired= if MP3DoFire(e1in, e2,1) then 1
		else 0;

MP3nbrEnd= 0 -> pre (MP3nbrFired);



(e1in_C, e2_C) = ((MP3nbrFired * MP3_e1in_rate_in), (MP3nbrFired * MP3_e2_rate_in));

(e1out_P, e3_P) = ((MP3nbrEnd * MP3_e1out_rate_out), (MP3nbrEnd * MP3_e3_rate_out));

tel;
------------------
node MP3DoFire(e1in, e2 :int; times: int) returns ( yes: bool);
let

yes = if  (e1in>=  (times * MP3_e1in_rate_in)) 
	and  (e2>=  (times * MP3_e2_rate_in)) 
	then true 
	else false;

tel;
------------------
node src(e4in, e3, e8 :int) returns (e4in_C, e4out_P, e3_C, e8_C, e2_P, e9_P :int; srcnbrFired: int );

var
srcnbrEnd: int;
let
srcnbrFired= if srcDoFire(e4in, e3, e8,1) then 1
		else 0;

srcnbrEnd= 0 -> pre (srcnbrFired);



(e4in_C, e3_C, e8_C) = ((srcnbrFired * src_e4in_rate_in), (srcnbrFired * src_e3_rate_in), (srcnbrFired * src_e8_rate_in));

(e4out_P, e2_P, e9_P) = ((srcnbrEnd * src_e4out_rate_out), (srcnbrEnd * src_e2_rate_out), (srcnbrEnd * src_e9_rate_out));

tel;
------------------
node srcDoFire(e4in, e3, e8 :int; times: int) returns ( yes: bool);
let

yes = if  (e4in>=  (times * src_e4in_rate_in)) 
	and  (e3>=  (times * src_e3_rate_in)) 
	and  (e8>=  (times * src_e8_rate_in)) 
	then true 
	else false;

tel;
------------------
node dac(e10in, e9 :int) returns (e10in_C, e10out_P, e9_C, e8_P :int; dacnbrFired: int );

var
dacnbrEnd: int;
let
dacnbrFired= if dacDoFire(e10in, e9,1) then 1
		else 0;

dacnbrEnd= 0 -> pre (dacnbrFired);



(e10in_C, e9_C) = ((dacnbrFired * dac_e10in_rate_in), (dacnbrFired * dac_e9_rate_in));

(e10out_P, e8_P) = ((dacnbrEnd * dac_e10out_rate_out), (dacnbrEnd * dac_e8_rate_out));

tel;
------------------
node dacDoFire(e10in, e9 :int; times: int) returns ( yes: bool);
let

yes = if  (e10in>=  (times * dac_e10in_rate_in)) 
	and  (e9>=  (times * dac_e9_rate_in)) 
	then true 
	else false;

tel;
------------------

--**************** Node Top Declaration ****************--

node top (_: bool) returns (e1, e4, e10, e2, e3, e8, e9, MP3nbrFired, srcnbrFired, dacnbrFired: int);

var

e1_C, e1_P: int; 
e4_C, e4_P: int; 
e10_C, e10_P: int; 
e2_C, e2_P: int; 
e3_C, e3_P: int; 
e8_C, e8_P: int; 
e9_C, e9_P: int; 
noDeadlock : bool;

let

e1 = e1_I -> pre ( e1-e1_C)+ e1_P;
e4 = e4_I -> pre ( e4-e4_C)+ e4_P;
e10 = e10_I -> pre ( e10-e10_C)+ e10_P;
e2 = e2_I -> pre ( e2-e2_C)+ e2_P;
e3 = e3_I -> pre ( e3-e3_C)+ e3_P;
e8 = e8_I -> pre ( e8-e8_C)+ e8_P;
e9 = e9_I -> pre ( e9-e9_C)+ e9_P;



(e1_C, e1_P, e2_C, e3_P, MP3nbrFired) = MP3(e1, e2);
(e4_C, e4_P, e3_C, e8_C, e2_P, e9_P, srcnbrFired) = src(e4, e3, e8);
(e10_C, e10_P, e9_C, e8_P, dacnbrFired) = dac(e10, e9);


noDeadlock = ( MP3nbrFired >= 1) 
	or  ( srcnbrFired >= 1) 
	or  ( dacnbrFired >= 1);
--%MAIN;

--%PROPERTY  "Deadlock free "  noDeadlock;


tel;


