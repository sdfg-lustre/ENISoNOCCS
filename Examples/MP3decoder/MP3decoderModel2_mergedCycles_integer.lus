--** This lustre code is generated automatically on 12 sept. 2020 11:24:14 PM
--** It corresponds to the translation of an SDFG model (mp3decoder)  to Lustre. This version produce a Lustre code having a reduced number of steps.




--**************** Const Rates ****************--

const huffman_p0_rate_out = 2;
const huffman_p1_rate_out = 2;
const huffman_p2_rate_in = 1;
const huffman_p3_rate_out = 1;
const huffman_p4_rate_in = 2;
const huffman_p5_rate_in = 2;
const req0_p0_rate_in = 1;
const req0_p1_rate_out = 1;
const req0_p2_rate_in = 1;
const req0_p3_rate_out = 1;
const reorder0_p0_rate_in = 1;
const reorder0_p1_rate_out = 1;
const req1_p0_rate_in = 1;
const req1_p1_rate_out = 1;
const req1_p2_rate_in = 1;
const req1_p3_rate_out = 1;
const reorder1_p0_rate_in = 1;
const reorder1_p1_rate_out = 1;
const stereo_p0_rate_in = 1;
const stereo_p1_rate_in = 1;
const stereo_p2_rate_out = 1;
const stereo_p3_rate_out = 1;
const antialias0_p0_rate_in = 1;
const antialias0_p1_rate_out = 1;
const hybridsynth0_p0_rate_in = 1;
const hybridsynth0_p1_rate_out = 1;
const freqinv0_p0_rate_in = 1;
const freqinv0_p1_rate_out = 1;
const subbinv0_p0_rate_in = 1;
const subbinv0_p1_rate_out = 1;
const antialias1_p0_rate_in = 1;
const antialias1_p1_rate_out = 1;
const hybridsynth1_p0_rate_in = 1;
const hybridsynth1_p1_rate_out = 1;
const freqinv1_p0_rate_in = 1;
const freqinv1_p1_rate_out = 1;
const subbinv1_p0_rate_in = 1;
const subbinv1_p1_rate_out = 1;

--****************  Actors' durations ****************--

const huffman_maxStages  = 1;
const huffman_duration  = 1;
const req0_maxStages  = 1;
const req0_duration  = 1;
const reorder0_maxStages  = 1;
const reorder0_duration  = 1;
const req1_maxStages  = 1;
const req1_duration  = 1;
const reorder1_maxStages  = 1;
const reorder1_duration  = 1;
const stereo_maxStages  = 1;
const stereo_duration  = 1;
const antialias0_maxStages  = 1;
const antialias0_duration  = 1;
const hybridsynth0_maxStages  = 1;
const hybridsynth0_duration  = 1;
const freqinv0_maxStages  = 1;
const freqinv0_duration  = 1;
const subbinv0_maxStages  = 1;
const subbinv0_duration  = 1;
const antialias1_maxStages  = 1;
const antialias1_duration  = 1;
const hybridsynth1_maxStages  = 1;
const hybridsynth1_duration  = 1;
const freqinv1_maxStages  = 1;
const freqinv1_duration  = 1;
const subbinv1_maxStages  = 1;
const subbinv1_duration  = 1;
const  maxDuration  = 1;

--**************** Init Channel ****************--

const ch0_I = 0;
const ch1_I = 0;
const ch2_I = 0;
const ch3_I = 0;
const ch4_I = 0;
const ch5_I = 0;
const ch6_I = 0;
const ch7_I = 0;
const ch8_I = 0;
const ch9_I = 0;
const ch10_I = 0;
const ch11_I = 0;
const ch12_I = 0;
const ch13_I = 0;
const ch14_I = 1;
const ch15_I = 1;
const ch16_I = 1;
const ch17_I = 2;
const ch18_I = 2;


--************************************************--
--******* Translation of Actor: huffman***************--
--************************************************--
node huffman(clock, p2, p4, p5 :int) returns (nextClock, p0_P, p1_P, p2_C, p3_P, p4_C, p5_C :int; nbrFired, nbrEnd: int );

let
nbrFired= if huffmanDoFire(p2, p4, p5,1) then 1
		else 0;

(p2_C, p4_C, p5_C) = ((nbrFired * huffman_p2_rate_in), (nbrFired * huffman_p4_rate_in), (nbrFired * huffman_p5_rate_in));

(p0_P, p1_P, p3_P) = ((nbrEnd * huffman_p0_rate_out), (nbrEnd * huffman_p1_rate_out), (nbrEnd * huffman_p3_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorhuffman-----------------
node huffmanDoFire(p2, p4, p5,times:int) returns ( yes: bool);
let

yes = if (p2>=  (times * huffman_p2_rate_in)) 
	and (p4>=  (times * huffman_p4_rate_in)) 
	and (p5>=  (times * huffman_p5_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: req0***************--
--************************************************--
node req0(clock, p0, p2 :int) returns (nextClock, p0_C, p1_P, p2_C, p3_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if req0DoFire(p0, p2,1) then 1
		else 0;

(p0_C, p2_C) = ((nbrFired * req0_p0_rate_in), (nbrFired * req0_p2_rate_in));

(p1_P, p3_P) = ((nbrEnd * req0_p1_rate_out), (nbrEnd * req0_p3_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorreq0-----------------
node req0DoFire(p0, p2,times:int) returns ( yes: bool);
let

yes = if (p0>=  (times * req0_p0_rate_in)) 
	and (p2>=  (times * req0_p2_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: reorder0***************--
--************************************************--
node reorder0(clock, p0 :int) returns (nextClock, p0_C, p1_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if reorder0DoFire(p0,1) then 1
		else 0;

(p0_C) = ((nbrFired * reorder0_p0_rate_in));

(p1_P) = ((nbrEnd * reorder0_p1_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorreorder0-----------------
node reorder0DoFire(p0,times:int) returns ( yes: bool);
let

yes = if (p0>=  (times * reorder0_p0_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: req1***************--
--************************************************--
node req1(clock, p0, p2 :int) returns (nextClock, p0_C, p1_P, p2_C, p3_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if req1DoFire(p0, p2,1) then 1
		else 0;

(p0_C, p2_C) = ((nbrFired * req1_p0_rate_in), (nbrFired * req1_p2_rate_in));

(p1_P, p3_P) = ((nbrEnd * req1_p1_rate_out), (nbrEnd * req1_p3_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorreq1-----------------
node req1DoFire(p0, p2,times:int) returns ( yes: bool);
let

yes = if (p0>=  (times * req1_p0_rate_in)) 
	and (p2>=  (times * req1_p2_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: reorder1***************--
--************************************************--
node reorder1(clock, p0 :int) returns (nextClock, p0_C, p1_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if reorder1DoFire(p0,1) then 1
		else 0;

(p0_C) = ((nbrFired * reorder1_p0_rate_in));

(p1_P) = ((nbrEnd * reorder1_p1_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorreorder1-----------------
node reorder1DoFire(p0,times:int) returns ( yes: bool);
let

yes = if (p0>=  (times * reorder1_p0_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: stereo***************--
--************************************************--
node stereo(clock, p0, p1 :int) returns (nextClock, p0_C, p1_C, p2_P, p3_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if stereoDoFire(p0, p1,1) then 1
		else 0;

(p0_C, p1_C) = ((nbrFired * stereo_p0_rate_in), (nbrFired * stereo_p1_rate_in));

(p2_P, p3_P) = ((nbrEnd * stereo_p2_rate_out), (nbrEnd * stereo_p3_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorstereo-----------------
node stereoDoFire(p0, p1,times:int) returns ( yes: bool);
let

yes = if (p0>=  (times * stereo_p0_rate_in)) 
	and (p1>=  (times * stereo_p1_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: antialias0***************--
--************************************************--
node antialias0(clock, p0 :int) returns (nextClock, p0_C, p1_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if antialias0DoFire(p0,1) then 1
		else 0;

(p0_C) = ((nbrFired * antialias0_p0_rate_in));

(p1_P) = ((nbrEnd * antialias0_p1_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorantialias0-----------------
node antialias0DoFire(p0,times:int) returns ( yes: bool);
let

yes = if (p0>=  (times * antialias0_p0_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: hybridsynth0***************--
--************************************************--
node hybridsynth0(clock, p0 :int) returns (nextClock, p0_C, p1_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if hybridsynth0DoFire(p0,1) then 1
		else 0;

(p0_C) = ((nbrFired * hybridsynth0_p0_rate_in));

(p1_P) = ((nbrEnd * hybridsynth0_p1_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorhybridsynth0-----------------
node hybridsynth0DoFire(p0,times:int) returns ( yes: bool);
let

yes = if (p0>=  (times * hybridsynth0_p0_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: freqinv0***************--
--************************************************--
node freqinv0(clock, p0 :int) returns (nextClock, p0_C, p1_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if freqinv0DoFire(p0,1) then 1
		else 0;

(p0_C) = ((nbrFired * freqinv0_p0_rate_in));

(p1_P) = ((nbrEnd * freqinv0_p1_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorfreqinv0-----------------
node freqinv0DoFire(p0,times:int) returns ( yes: bool);
let

yes = if (p0>=  (times * freqinv0_p0_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: subbinv0***************--
--************************************************--
node subbinv0(clock, p0 :int) returns (nextClock, p0_C, p1_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if subbinv0DoFire(p0,1) then 1
		else 0;

(p0_C) = ((nbrFired * subbinv0_p0_rate_in));

(p1_P) = ((nbrEnd * subbinv0_p1_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorsubbinv0-----------------
node subbinv0DoFire(p0,times:int) returns ( yes: bool);
let

yes = if (p0>=  (times * subbinv0_p0_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: antialias1***************--
--************************************************--
node antialias1(clock, p0 :int) returns (nextClock, p0_C, p1_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if antialias1DoFire(p0,1) then 1
		else 0;

(p0_C) = ((nbrFired * antialias1_p0_rate_in));

(p1_P) = ((nbrEnd * antialias1_p1_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorantialias1-----------------
node antialias1DoFire(p0,times:int) returns ( yes: bool);
let

yes = if (p0>=  (times * antialias1_p0_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: hybridsynth1***************--
--************************************************--
node hybridsynth1(clock, p0 :int) returns (nextClock, p0_C, p1_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if hybridsynth1DoFire(p0,1) then 1
		else 0;

(p0_C) = ((nbrFired * hybridsynth1_p0_rate_in));

(p1_P) = ((nbrEnd * hybridsynth1_p1_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorhybridsynth1-----------------
node hybridsynth1DoFire(p0,times:int) returns ( yes: bool);
let

yes = if (p0>=  (times * hybridsynth1_p0_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: freqinv1***************--
--************************************************--
node freqinv1(clock, p0 :int) returns (nextClock, p0_C, p1_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if freqinv1DoFire(p0,1) then 1
		else 0;

(p0_C) = ((nbrFired * freqinv1_p0_rate_in));

(p1_P) = ((nbrEnd * freqinv1_p1_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorfreqinv1-----------------
node freqinv1DoFire(p0,times:int) returns ( yes: bool);
let

yes = if (p0>=  (times * freqinv1_p0_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: subbinv1***************--
--************************************************--
node subbinv1(clock, p0 :int) returns (nextClock, p0_C, p1_P :int; nbrFired, nbrEnd: int );

let
nbrFired= if subbinv1DoFire(p0,1) then 1
		else 0;

(p0_C) = ((nbrFired * subbinv1_p0_rate_in));

(p1_P) = ((nbrEnd * subbinv1_p1_rate_out));

nbrEnd = 0 -> pre nbrFired  ;
nextClock = if (nbrFired = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorsubbinv1-----------------
node subbinv1DoFire(p0,times:int) returns ( yes: bool);
let

yes = if (p0>=  (times * subbinv1_p0_rate_in)) 
	then true 
	else false;

tel;
--******* Node Min***************--
node Min (x, y :int) returns ( r: int);
let
r= if  (x < y) then x else y;
tel;

--************************************************--
--******* Node Top***************--
--************************************************--
node top (_: bool) returns ( adv, ch0, ch1, ch2, ch3, ch4, ch5, ch6, ch7, ch8, ch9, ch10, ch11, ch12, ch13, ch14, ch15, ch16, ch17, ch18, huffmannbrFired, req0nbrFired, reorder0nbrFired, req1nbrFired, reorder1nbrFired, stereonbrFired, antialias0nbrFired, hybridsynth0nbrFired, freqinv0nbrFired, subbinv0nbrFired, antialias1nbrFired, hybridsynth1nbrFired, freqinv1nbrFired, subbinv1nbrFired:int);

var

ch0_C, ch0_P: int; 
ch1_C, ch1_P: int; 
ch2_C, ch2_P: int; 
ch3_C, ch3_P: int; 
ch4_C, ch4_P: int; 
ch5_C, ch5_P: int; 
ch6_C, ch6_P: int; 
ch7_C, ch7_P: int; 
ch8_C, ch8_P: int; 
ch9_C, ch9_P: int; 
ch10_C, ch10_P: int; 
ch11_C, ch11_P: int; 
ch12_C, ch12_P: int; 
ch13_C, ch13_P: int; 
ch14_C, ch14_P: int; 
ch15_C, ch15_P: int; 
ch16_C, ch16_P: int; 
ch17_C, ch17_P: int; 
ch18_C, ch18_P: int; 
huffmannextClock : int;  
req0nextClock : int;  
reorder0nextClock : int;  
req1nextClock : int;  
reorder1nextClock : int;  
stereonextClock : int;  
antialias0nextClock : int;  
hybridsynth0nextClock : int;  
freqinv0nextClock : int;  
subbinv0nextClock : int;  
antialias1nextClock : int;  
hybridsynth1nextClock : int;  
freqinv1nextClock : int;  
subbinv1nextClock : int;  
huffmannbrEnd, req0nbrEnd, reorder0nbrEnd, req1nbrEnd, reorder1nbrEnd, stereonbrEnd, antialias0nbrEnd, hybridsynth0nbrEnd, freqinv0nbrEnd, subbinv0nbrEnd, antialias1nbrEnd, hybridsynth1nbrEnd, freqinv1nbrEnd, subbinv1nbrEnd : int; 

huffmannbrRun, req0nbrRun, reorder0nbrRun, req1nbrRun, reorder1nbrRun, stereonbrRun, antialias0nbrRun, hybridsynth0nbrRun, freqinv0nbrRun, subbinv0nbrRun, antialias1nbrRun, hybridsynth1nbrRun, freqinv1nbrRun, subbinv1nbrRun : int; 

positiveValues, noDeadlock: bool; 

let

ch0 = ch0_I ->  ( pre ( ch0 - ch0_C) + ch0_P);
ch1 = ch1_I ->  ( pre ( ch1 - ch1_C) + ch1_P);
ch2 = ch2_I ->  ( pre ( ch2 - ch2_C) + ch2_P);
ch3 = ch3_I ->  ( pre ( ch3 - ch3_C) + ch3_P);
ch4 = ch4_I ->  ( pre ( ch4 - ch4_C) + ch4_P);
ch5 = ch5_I ->  ( pre ( ch5 - ch5_C) + ch5_P);
ch6 = ch6_I ->  ( pre ( ch6 - ch6_C) + ch6_P);
ch7 = ch7_I ->  ( pre ( ch7 - ch7_C) + ch7_P);
ch8 = ch8_I ->  ( pre ( ch8 - ch8_C) + ch8_P);
ch9 = ch9_I ->  ( pre ( ch9 - ch9_C) + ch9_P);
ch10 = ch10_I ->  ( pre ( ch10 - ch10_C) + ch10_P);
ch11 = ch11_I ->  ( pre ( ch11 - ch11_C) + ch11_P);
ch12 = ch12_I ->  ( pre ( ch12 - ch12_C) + ch12_P);
ch13 = ch13_I ->  ( pre ( ch13 - ch13_C) + ch13_P);
ch14 = ch14_I ->  ( pre ( ch14 - ch14_C) + ch14_P);
ch15 = ch15_I ->  ( pre ( ch15 - ch15_C) + ch15_P);
ch16 = ch16_I ->  ( pre ( ch16 - ch16_C) + ch16_P);
ch17 = ch17_I ->  ( pre ( ch17 - ch17_C) + ch17_P);
ch18 = ch18_I ->  ( pre ( ch18 - ch18_C) + ch18_P);




(huffmannextClock, ch0_P, ch1_P, ch14_C, ch14_P, ch17_C, ch18_C, huffmannbrFired, huffmannbrEnd ) = huffman(adv, ch14, ch17, ch18);
(req0nextClock, ch0_C, ch2_P, ch15_C, ch15_P, req0nbrFired, req0nbrEnd ) = req0(adv, ch0, ch15);
(reorder0nextClock, ch2_C, ch4_P, reorder0nbrFired, reorder0nbrEnd ) = reorder0(adv, ch2);
(req1nextClock, ch1_C, ch3_P, ch16_C, ch16_P, req1nbrFired, req1nbrEnd ) = req1(adv, ch1, ch16);
(reorder1nextClock, ch3_C, ch5_P, reorder1nbrFired, reorder1nbrEnd ) = reorder1(adv, ch3);
(stereonextClock, ch4_C, ch5_C, ch6_P, ch7_P, stereonbrFired, stereonbrEnd ) = stereo(adv, ch4, ch5);
(antialias0nextClock, ch6_C, ch8_P, antialias0nbrFired, antialias0nbrEnd ) = antialias0(adv, ch6);
(hybridsynth0nextClock, ch8_C, ch10_P, hybridsynth0nbrFired, hybridsynth0nbrEnd ) = hybridsynth0(adv, ch8);
(freqinv0nextClock, ch10_C, ch12_P, freqinv0nbrFired, freqinv0nbrEnd ) = freqinv0(adv, ch10);
(subbinv0nextClock, ch12_C, ch17_P, subbinv0nbrFired, subbinv0nbrEnd ) = subbinv0(adv, ch12);
(antialias1nextClock, ch7_C, ch9_P, antialias1nbrFired, antialias1nbrEnd ) = antialias1(adv, ch7);
(hybridsynth1nextClock, ch9_C, ch11_P, hybridsynth1nbrFired, hybridsynth1nbrEnd ) = hybridsynth1(adv, ch9);
(freqinv1nextClock, ch11_C, ch13_P, freqinv1nbrFired, freqinv1nbrEnd ) = freqinv1(adv, ch11);
(subbinv1nextClock, ch13_C, ch18_P, subbinv1nbrFired, subbinv1nbrEnd ) = subbinv1(adv, ch13);

adv= Min(huffmannextClock , Min(req0nextClock , Min(reorder0nextClock , Min(req1nextClock , Min(reorder1nextClock , Min(stereonextClock , Min(antialias0nextClock , Min(hybridsynth0nextClock , Min(freqinv0nextClock , Min(subbinv0nextClock , Min(antialias1nextClock , Min(hybridsynth1nextClock , Min(freqinv1nextClock , subbinv1nextClock)))))))))))));


huffmannbrRun=  huffmannbrFired  -> (pre huffmannbrRun) +huffmannbrFired - huffmannbrEnd ;

req0nbrRun=  req0nbrFired  -> (pre req0nbrRun) +req0nbrFired - req0nbrEnd ;

reorder0nbrRun=  reorder0nbrFired  -> (pre reorder0nbrRun) +reorder0nbrFired - reorder0nbrEnd ;

req1nbrRun=  req1nbrFired  -> (pre req1nbrRun) +req1nbrFired - req1nbrEnd ;

reorder1nbrRun=  reorder1nbrFired  -> (pre reorder1nbrRun) +reorder1nbrFired - reorder1nbrEnd ;

stereonbrRun=  stereonbrFired  -> (pre stereonbrRun) +stereonbrFired - stereonbrEnd ;

antialias0nbrRun=  antialias0nbrFired  -> (pre antialias0nbrRun) +antialias0nbrFired - antialias0nbrEnd ;

hybridsynth0nbrRun=  hybridsynth0nbrFired  -> (pre hybridsynth0nbrRun) +hybridsynth0nbrFired - hybridsynth0nbrEnd ;

freqinv0nbrRun=  freqinv0nbrFired  -> (pre freqinv0nbrRun) +freqinv0nbrFired - freqinv0nbrEnd ;

subbinv0nbrRun=  subbinv0nbrFired  -> (pre subbinv0nbrRun) +subbinv0nbrFired - subbinv0nbrEnd ;

antialias1nbrRun=  antialias1nbrFired  -> (pre antialias1nbrRun) +antialias1nbrFired - antialias1nbrEnd ;

hybridsynth1nbrRun=  hybridsynth1nbrFired  -> (pre hybridsynth1nbrRun) +hybridsynth1nbrFired - hybridsynth1nbrEnd ;

freqinv1nbrRun=  freqinv1nbrFired  -> (pre freqinv1nbrRun) +freqinv1nbrFired - freqinv1nbrEnd ;

subbinv1nbrRun=  subbinv1nbrFired  -> (pre subbinv1nbrRun) +subbinv1nbrFired - subbinv1nbrEnd ;


positiveValues = ( ch0 >= 0) 
	and ( ch1 >= 0) 
	and ( ch2 >= 0) 
	and ( ch3 >= 0) 
	and ( ch4 >= 0) 
	and ( ch5 >= 0) 
	and ( ch6 >= 0) 
	and ( ch7 >= 0) 
	and ( ch8 >= 0) 
	and ( ch9 >= 0) 
	and ( ch10 >= 0) 
	and ( ch11 >= 0) 
	and ( ch12 >= 0) 
	and ( ch13 >= 0) 
	and ( ch14 >= 0) 
	and ( ch15 >= 0) 
	and ( ch16 >= 0) 
	and ( ch17 >= 0) 
	and ( ch18 >= 0) 
	and ( huffmannbrFired  >=  0) 
	and ( req0nbrFired  >=  0) 
	and ( reorder0nbrFired  >=  0) 
	and ( req1nbrFired  >=  0) 
	and ( reorder1nbrFired  >=  0) 
	and ( stereonbrFired  >=  0) 
	and ( antialias0nbrFired  >=  0) 
	and ( hybridsynth0nbrFired  >=  0) 
	and ( freqinv0nbrFired  >=  0) 
	and ( subbinv0nbrFired  >=  0) 
	and ( antialias1nbrFired  >=  0) 
	and ( hybridsynth1nbrFired  >=  0) 
	and ( freqinv1nbrFired  >=  0) 
	and ( subbinv1nbrFired  >=  0) ;

noDeadlock = ( huffmannbrRun >= 1) 
	or  ( req0nbrRun >= 1) 
	or  ( reorder0nbrRun >= 1) 
	or  ( req1nbrRun >= 1) 
	or  ( reorder1nbrRun >= 1) 
	or  ( stereonbrRun >= 1) 
	or  ( antialias0nbrRun >= 1) 
	or  ( hybridsynth0nbrRun >= 1) 
	or  ( freqinv0nbrRun >= 1) 
	or  ( subbinv0nbrRun >= 1) 
	or  ( antialias1nbrRun >= 1) 
	or  ( hybridsynth1nbrRun >= 1) 
	or  ( freqinv1nbrRun >= 1) 
	or  ( subbinv1nbrRun >= 1);
--%MAIN;

--%PROPERTY  "Ok, all variables are positive "  positiveValues;

--%PROPERTY  "no deadlock "  noDeadlock;


tel;


