--** This lustre code is generated automatically on 13 sept. 2020 12:27:27 PM
--**It corresponds to a translation to Lustre of the  SDFG model  of the design "SDFG " 



--**************** Const Rates ****************--

const f_fin_rate_in = 1;
const f_fout_rate_out = 1;
const f_af_rate_in = 1;
const f_fa_rate_out = 1;
const a_fa_rate_in = 2;
const a_ba_rate_in = 3;
const a_ea_rate_in = 12;
const a_af_rate_out = 2;
const a_ab_rate_out = 3;
const a_ae_rate_out = 12;
const b_bin_rate_in = 1;
const b_bout_rate_out = 1;
const b_ab_rate_in = 5;
const b_cb_rate_in = 2;
const b_eb_rate_in = 4;
const b_ba_rate_out = 5;
const b_bc_rate_out = 2;
const b_be_rate_out = 4;
const c_bc_rate_in = 3;
const c_dc_rate_in = 3;
const c_cb_rate_out = 3;
const c_cd_rate_out = 3;
const d_din_rate_in = 1;
const d_dout_rate_out = 1;
const d_cd_rate_in = 1;
const d_ed_rate_in = 2;
const d_dc_rate_out = 1;
const d_de_rate_out = 2;
const e_ae_rate_in = 5;
const e_be_rate_in = 1;
const e_de_rate_in = 1;
const e_ea_rate_out = 5;
const e_eb_rate_out = 1;
const e_ed_rate_out = 1;

--**************** Init Channel ****************--

const f_I = 1 ;
const b_I = 1 ;
const d_I = 1 ;
const fa_I = 4 ;
const af_I = 0 ;
const ab_I = 0 ;
const ae_I = 35 ;
const ba_I = 9 ;
const bc_I = 1 ;
const be_I = 0 ;
const cb_I = 6 ;
const cd_I = 0 ;
const dc_I = 5 ;
const de_I = 4 ;
const ea_I = 26 ;
const eb_I = 8 ;
const ed_I = 0 ;


--**************** Actors Translation ****************--

node f(fin, af :int) returns (fin_C, fout_P, af_C, fa_P :int; fnbrFired, fnbrEnd : int );

let
fnbrFired= if fDoFire(fin, af,1) then 1
		else 0;

fnbrEnd= 0 -> pre (0 -> pre (fnbrFired));



(fin_C, af_C) = ((fnbrFired * f_fin_rate_in), (fnbrFired * f_af_rate_in));

(fout_P, fa_P) = ((fnbrEnd * f_fout_rate_out), (fnbrEnd * f_fa_rate_out));

tel;
------------------
node fDoFire(fin, af :int; times: int) returns ( yes: bool);
let

yes = if  (fin>=  (times * f_fin_rate_in)) 
	and  (af>=  (times * f_af_rate_in)) 
	then true 
	else false;

tel;
------------------
node a(fa, ba, ea :int) returns (fa_C, ba_C, ea_C, af_P, ab_P, ae_P :int; anbrFired, anbrEnd : int );

let
anbrFired= if aDoFire(fa, ba, ea,2) then 2
		else if aDoFire(fa, ba, ea,1) then 1
		else 0;

anbrEnd= 0 -> pre (0 -> pre (anbrFired));



(fa_C, ba_C, ea_C) = ((anbrFired * a_fa_rate_in), (anbrFired * a_ba_rate_in), (anbrFired * a_ea_rate_in));

(af_P, ab_P, ae_P) = ((anbrEnd * a_af_rate_out), (anbrEnd * a_ab_rate_out), (anbrEnd * a_ae_rate_out));

tel;
------------------
node aDoFire(fa, ba, ea :int; times: int) returns ( yes: bool);
let

yes = if  (fa>=  (times * a_fa_rate_in)) 
	and  (ba>=  (times * a_ba_rate_in)) 
	and  (ea>=  (times * a_ea_rate_in)) 
	then true 
	else false;

tel;
------------------
node b(bin, ab, cb, eb :int) returns (bin_C, bout_P, ab_C, cb_C, eb_C, ba_P, bc_P, be_P :int; bnbrFired, bnbrEnd : int );

let
bnbrFired= if bDoFire(bin, ab, cb, eb,1) then 1
		else 0;

bnbrEnd= 0 -> pre (0 -> pre (bnbrFired));



(bin_C, ab_C, cb_C, eb_C) = ((bnbrFired * b_bin_rate_in), (bnbrFired * b_ab_rate_in), (bnbrFired * b_cb_rate_in), (bnbrFired * b_eb_rate_in));

(bout_P, ba_P, bc_P, be_P) = ((bnbrEnd * b_bout_rate_out), (bnbrEnd * b_ba_rate_out), (bnbrEnd * b_bc_rate_out), (bnbrEnd * b_be_rate_out));

tel;
------------------
node bDoFire(bin, ab, cb, eb :int; times: int) returns ( yes: bool);
let

yes = if  (bin>=  (times * b_bin_rate_in)) 
	and  (ab>=  (times * b_ab_rate_in)) 
	and  (cb>=  (times * b_cb_rate_in)) 
	and  (eb>=  (times * b_eb_rate_in)) 
	then true 
	else false;

tel;
------------------
node c(bc, dc :int) returns (bc_C, dc_C, cb_P, cd_P :int; cnbrFired, cnbrEnd : int );

let
cnbrFired= if cDoFire(bc, dc,2) then 2
		else if cDoFire(bc, dc,1) then 1
		else 0;

cnbrEnd= 0 -> pre (0 -> pre (cnbrFired));



(bc_C, dc_C) = ((cnbrFired * c_bc_rate_in), (cnbrFired * c_dc_rate_in));

(cb_P, cd_P) = ((cnbrEnd * c_cb_rate_out), (cnbrEnd * c_cd_rate_out));

tel;
------------------
node cDoFire(bc, dc :int; times: int) returns ( yes: bool);
let

yes = if  (bc>=  (times * c_bc_rate_in)) 
	and  (dc>=  (times * c_dc_rate_in)) 
	then true 
	else false;

tel;
------------------
node d(din, cd, ed :int) returns (din_C, dout_P, cd_C, ed_C, dc_P, de_P :int; dnbrFired, dnbrEnd : int );

let
dnbrFired= if dDoFire(din, cd, ed,1) then 1
		else 0;

dnbrEnd= 0 -> pre (0 -> pre (dnbrFired));



(din_C, cd_C, ed_C) = ((dnbrFired * d_din_rate_in), (dnbrFired * d_cd_rate_in), (dnbrFired * d_ed_rate_in));

(dout_P, dc_P, de_P) = ((dnbrEnd * d_dout_rate_out), (dnbrEnd * d_dc_rate_out), (dnbrEnd * d_de_rate_out));

tel;
------------------
node dDoFire(din, cd, ed :int; times: int) returns ( yes: bool);
let

yes = if  (din>=  (times * d_din_rate_in)) 
	and  (cd>=  (times * d_cd_rate_in)) 
	and  (ed>=  (times * d_ed_rate_in)) 
	then true 
	else false;

tel;
------------------
node e(ae, be, de :int) returns (ae_C, be_C, de_C, ea_P, eb_P, ed_P :int; enbrFired, enbrEnd : int );

let
enbrFired= if eDoFire(ae, be, de,2) then 2
		else if eDoFire(ae, be, de,1) then 1
		else 0;

enbrEnd= 0 -> pre (0 -> pre (enbrFired));



(ae_C, be_C, de_C) = ((enbrFired * e_ae_rate_in), (enbrFired * e_be_rate_in), (enbrFired * e_de_rate_in));

(ea_P, eb_P, ed_P) = ((enbrEnd * e_ea_rate_out), (enbrEnd * e_eb_rate_out), (enbrEnd * e_ed_rate_out));

tel;
------------------
node eDoFire(ae, be, de :int; times: int) returns ( yes: bool);
let

yes = if  (ae>=  (times * e_ae_rate_in)) 
	and  (be>=  (times * e_be_rate_in)) 
	and  (de>=  (times * e_de_rate_in)) 
	then true 
	else false;

tel;
------------------
node top (_: bool) returns (f, b, d, fa, af, ab, ae, ba, bc, be, cb, cd, dc, de, ea, eb, ed, fnbrFired, anbrFired, bnbrFired, cnbrFired, dnbrFired, enbrFired: int);

-------------- Les variables -------------- 

var

f_C, f_P: int; 
b_C, b_P: int; 
d_C, d_P: int; 
fa_C, fa_P: int; 
af_C, af_P: int; 
ab_C, ab_P: int; 
ae_C, ae_P: int; 
ba_C, ba_P: int; 
bc_C, bc_P: int; 
be_C, be_P: int; 
cb_C, cb_P: int; 
cd_C, cd_P: int; 
dc_C, dc_P: int; 
de_C, de_P: int; 
ea_C, ea_P: int; 
eb_C, eb_P: int; 
ed_C, ed_P: int; 
fnbrEnd, anbrEnd, bnbrEnd, cnbrEnd, dnbrEnd, enbrEnd : int; 

fnbrRun, anbrRun, bnbrRun, cnbrRun, dnbrRun, enbrRun : int; 

positiveValues, noDeadlock: bool;


let

f = f_I -> pre  (   f-f_C)+ f_P;
b = b_I -> pre  (   b-b_C)+ b_P;
d = d_I -> pre  (   d-d_C)+ d_P;
fa = fa_I -> pre  (   fa-fa_C)+ fa_P;
af = af_I -> pre  (   af-af_C)+ af_P;
ab = ab_I -> pre  (   ab-ab_C)+ ab_P;
ae = ae_I -> pre  (   ae-ae_C)+ ae_P;
ba = ba_I -> pre  (   ba-ba_C)+ ba_P;
bc = bc_I -> pre  (   bc-bc_C)+ bc_P;
be = be_I -> pre  (   be-be_C)+ be_P;
cb = cb_I -> pre  (   cb-cb_C)+ cb_P;
cd = cd_I -> pre  (   cd-cd_C)+ cd_P;
dc = dc_I -> pre  (   dc-dc_C)+ dc_P;
de = de_I -> pre  (   de-de_C)+ de_P;
ea = ea_I -> pre  (   ea-ea_C)+ ea_P;
eb = eb_I -> pre  (   eb-eb_C)+ eb_P;
ed = ed_I -> pre  (   ed-ed_C)+ ed_P;



(f_C, f_P, af_C, fa_P, fnbrFired, fnbrEnd ) = f(f, af);
(fa_C, ba_C, ea_C, af_P, ab_P, ae_P, anbrFired, anbrEnd ) = a(fa, ba, ea);
(b_C, b_P, ab_C, cb_C, eb_C, ba_P, bc_P, be_P, bnbrFired, bnbrEnd ) = b(b, ab, cb, eb);
(bc_C, dc_C, cb_P, cd_P, cnbrFired, cnbrEnd ) = c(bc, dc);
(d_C, d_P, cd_C, ed_C, dc_P, de_P, dnbrFired, dnbrEnd ) = d(d, cd, ed);
(ae_C, be_C, de_C, ea_P, eb_P, ed_P, enbrFired, enbrEnd ) = e(ae, be, de);

fnbrRun=  fnbrFired  -> (pre fnbrRun) +fnbrFired - fnbrEnd ;

anbrRun=  anbrFired  -> (pre anbrRun) +anbrFired - anbrEnd ;

bnbrRun=  bnbrFired  -> (pre bnbrRun) +bnbrFired - bnbrEnd ;

cnbrRun=  cnbrFired  -> (pre cnbrRun) +cnbrFired - cnbrEnd ;

dnbrRun=  dnbrFired  -> (pre dnbrRun) +dnbrFired - dnbrEnd ;

enbrRun=  enbrFired  -> (pre enbrRun) +enbrFired - enbrEnd ;


positiveValues = ( f>=   0) 
	and  ( b>=   0) 
	and  ( d>=   0) 
	and  ( fa>=   0) 
	and  ( af>=   0) 
	and  ( ab>=   0) 
	and  ( ae>=   0) 
	and  ( ba>=   0) 
	and  ( bc>=   0) 
	and  ( be>=   0) 
	and  ( cb>=   0) 
	and  ( cd>=   0) 
	and  ( dc>=   0) 
	and  ( de>=   0) 
	and  ( ea>=   0) 
	and  ( eb>=   0) 
	and  ( ed>=   0) 
	and  ( fnbrFired >= 0) 
	and  ( anbrFired >= 0) 
	and  ( bnbrFired >= 0) 
	and  ( cnbrFired >= 0) 
	and  ( dnbrFired >= 0) 
	and  ( enbrFired >= 0) ;

noDeadlock = ( fnbrRun >= 1) 
	or  ( anbrRun >= 1) 
	or  ( bnbrRun >= 1) 
	or  ( cnbrRun >= 1) 
	or  ( dnbrRun >= 1) 
	or  ( enbrRun >= 1);

--%MAIN;

--%PROPERTY  "Ok, all variables are positive "  positiveValues;


--%PROPERTY  "Deadlock free "  noDeadlock;


tel;

