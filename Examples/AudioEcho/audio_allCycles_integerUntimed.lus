--** This lustre code is generated automatically on 12 sept. 2020 11:32:21 PM
--**It corresponds to a translation to Lustre of the Untimed SDFG model  of the design "audioEcho" 




--**************** Const Rates ****************--

const out_e1in_rate_in = 1 ;
const out_e1out_rate_out = 1 ;
const out_e2_rate_in = 1 ;
const out_e3_rate_out = 1 ;
const abc_e4in_rate_in = 1 ;
const abc_e4out_rate_out = 1 ;
const abc_e3_rate_in = 23 ;
const abc_e6_rate_in = 23 ;
const abc_e8_rate_in = 23 ;
const abc_e2_rate_out = 23 ;
const abc_e5_rate_out = 23 ;
const abc_e9_rate_out = 23 ;
const src_e7in_rate_in = 1 ;
const src_e7out_rate_out = 1 ;
const src_e5_rate_in = 1 ;
const src_e6_rate_out = 1 ;
const adc_e10in_rate_in = 1 ;
const adc_e10out_rate_out = 1 ;
const adc_e9_rate_in = 1 ;
const adc_e8_rate_out = 1 ;

--**************** Init Channel ****************--

const e1_I = 1 ;
const e4_I = 1 ;
const e7_I = 1 ;
const e10_I = 1 ;
const e2_I = 0 ;
const e3_I = 44 ;
const e5_I = 44 ;
const e6_I = 0 ;
const e8_I = 0 ;
const e9_I = 44 ;


--**************** Nodes Declaration ****************--

node out(e1in, e2 :int) returns (e1in_C, e1out_P, e2_C, e3_P :int; outnbrFired: int );

var
outnbrEnd: int;
let
outnbrFired= if outDoFire(e1in, e2,2) then 2
		else if outDoFire(e1in, e2,1) then 1
		else 0;

outnbrEnd= 0 -> pre (outnbrFired);



(e1in_C, e2_C) = ((outnbrFired * out_e1in_rate_in), (outnbrFired * out_e2_rate_in));

(e1out_P, e3_P) = ((outnbrEnd * out_e1out_rate_out), (outnbrEnd * out_e3_rate_out));

tel;
------------------
node outDoFire(e1in, e2 :int; times: int) returns ( yes: bool);
let

yes = if  (e1in>=  (times * out_e1in_rate_in)) 
	and  (e2>=  (times * out_e2_rate_in)) 
	then true 
	else false;

tel;
------------------
node abc(e4in, e3, e6, e8 :int) returns (e4in_C, e4out_P, e3_C, e6_C, e8_C, e2_P, e5_P, e9_P :int; abcnbrFired: int );

var
abcnbrEnd: int;
let
abcnbrFired= if abcDoFire(e4in, e3, e6, e8,2) then 2
		else if abcDoFire(e4in, e3, e6, e8,1) then 1
		else 0;

abcnbrEnd= 0 -> pre (abcnbrFired);



(e4in_C, e3_C, e6_C, e8_C) = ((abcnbrFired * abc_e4in_rate_in), (abcnbrFired * abc_e3_rate_in), (abcnbrFired * abc_e6_rate_in), (abcnbrFired * abc_e8_rate_in));

(e4out_P, e2_P, e5_P, e9_P) = ((abcnbrEnd * abc_e4out_rate_out), (abcnbrEnd * abc_e2_rate_out), (abcnbrEnd * abc_e5_rate_out), (abcnbrEnd * abc_e9_rate_out));

tel;
------------------
node abcDoFire(e4in, e3, e6, e8 :int; times: int) returns ( yes: bool);
let

yes = if  (e4in>=  (times * abc_e4in_rate_in)) 
	and  (e3>=  (times * abc_e3_rate_in)) 
	and  (e6>=  (times * abc_e6_rate_in)) 
	and  (e8>=  (times * abc_e8_rate_in)) 
	then true 
	else false;

tel;
------------------
node src(e7in, e5 :int) returns (e7in_C, e7out_P, e5_C, e6_P :int; srcnbrFired: int );

var
srcnbrEnd: int;
let
srcnbrFired= if srcDoFire(e7in, e5,2) then 2
		else if srcDoFire(e7in, e5,1) then 1
		else 0;

srcnbrEnd= 0 -> pre (srcnbrFired);



(e7in_C, e5_C) = ((srcnbrFired * src_e7in_rate_in), (srcnbrFired * src_e5_rate_in));

(e7out_P, e6_P) = ((srcnbrEnd * src_e7out_rate_out), (srcnbrEnd * src_e6_rate_out));

tel;
------------------
node srcDoFire(e7in, e5 :int; times: int) returns ( yes: bool);
let

yes = if  (e7in>=  (times * src_e7in_rate_in)) 
	and  (e5>=  (times * src_e5_rate_in)) 
	then true 
	else false;

tel;
------------------
node adc(e10in, e9 :int) returns (e10in_C, e10out_P, e9_C, e8_P :int; adcnbrFired: int );

var
adcnbrEnd: int;
let
adcnbrFired= if adcDoFire(e10in, e9,2) then 2
		else if adcDoFire(e10in, e9,1) then 1
		else 0;

adcnbrEnd= 0 -> pre (adcnbrFired);



(e10in_C, e9_C) = ((adcnbrFired * adc_e10in_rate_in), (adcnbrFired * adc_e9_rate_in));

(e10out_P, e8_P) = ((adcnbrEnd * adc_e10out_rate_out), (adcnbrEnd * adc_e8_rate_out));

tel;
------------------
node adcDoFire(e10in, e9 :int; times: int) returns ( yes: bool);
let

yes = if  (e10in>=  (times * adc_e10in_rate_in)) 
	and  (e9>=  (times * adc_e9_rate_in)) 
	then true 
	else false;

tel;
------------------

--**************** Node Top Declaration ****************--

node top (_: bool) returns (e1, e4, e7, e10, e2, e3, e5, e6, e8, e9, outnbrFired, abcnbrFired, srcnbrFired, adcnbrFired: int);

var

e1_C, e1_P: int; 
e4_C, e4_P: int; 
e7_C, e7_P: int; 
e10_C, e10_P: int; 
e2_C, e2_P: int; 
e3_C, e3_P: int; 
e5_C, e5_P: int; 
e6_C, e6_P: int; 
e8_C, e8_P: int; 
e9_C, e9_P: int; 
noDeadlock : bool;

let

e1 = e1_I -> pre ( e1-e1_C)+ e1_P;
e4 = e4_I -> pre ( e4-e4_C)+ e4_P;
e7 = e7_I -> pre ( e7-e7_C)+ e7_P;
e10 = e10_I -> pre ( e10-e10_C)+ e10_P;
e2 = e2_I -> pre ( e2-e2_C)+ e2_P;
e3 = e3_I -> pre ( e3-e3_C)+ e3_P;
e5 = e5_I -> pre ( e5-e5_C)+ e5_P;
e6 = e6_I -> pre ( e6-e6_C)+ e6_P;
e8 = e8_I -> pre ( e8-e8_C)+ e8_P;
e9 = e9_I -> pre ( e9-e9_C)+ e9_P;



(e1_C, e1_P, e2_C, e3_P, outnbrFired) = out(e1, e2);
(e4_C, e4_P, e3_C, e6_C, e8_C, e2_P, e5_P, e9_P, abcnbrFired) = abc(e4, e3, e6, e8);
(e7_C, e7_P, e5_C, e6_P, srcnbrFired) = src(e7, e5);
(e10_C, e10_P, e9_C, e8_P, adcnbrFired) = adc(e10, e9);


noDeadlock = ( outnbrFired >= 1) 
	or  ( abcnbrFired >= 1) 
	or  ( srcnbrFired >= 1) 
	or  ( adcnbrFired >= 1);
--%MAIN;

--%PROPERTY  "Deadlock free "  noDeadlock;


tel;


