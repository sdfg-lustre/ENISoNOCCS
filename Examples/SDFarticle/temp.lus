--** This lustre code is generated automatically on 16 juin 2020 10:28:52 AM
--** It corresponds to the translation of an SDFG model (example)  to Lustre. This version produce a Lustre code having a reduced number of steps.




--**************** Const Rates ****************--

const a_e4_rate_in = 3;
const a_e1_rate_out = 3;
const b_e1_rate_in = 1;
const b_e3_rate_in = 1;
const b_e2_rate_out = 1;
const c_e2_rate_in = 1;
const c_e5in_rate_in = 1;
const c_e5out_rate_out = 1;
const c_e3_rate_out = 1;
const c_e4_rate_out = 1;

--****************  Actors' durations ****************--

const a_maxstages  = 1;
const a_duration  = 1;
const b_maxstages  = 2;
const b_duration  = 3;
const c_maxstages  = 1;
const c_duration  = 1;
const  maxDuration  = 3;

--**************** Init Channel ****************--

const e1_I = 0;
const e2_I = 0;
const e3_I = 2;
const e4_I = 5;
const e5_I = 1;


--************************************************--
--******* Translation of Actor: a***************--
--************************************************--
node a(clock, e4 :int) returns (nextClock, e4_C, e1_P :int; Fa: int );

var
Ea: int;
let
Fa= if aDoFire(e4,1) then 1
		else 0;

(e4_C) = ((Fa * a_e4_rate_in));

Ea = 0 -> pre Fa  ;
(e1_P) = ((Ea * a_e1_rate_out));

nextClock = if (Fa = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actora-----------------
node aDoFire(e4,times:int) returns ( yes: bool);
let

yes = if (e4>=  (times * a_e4_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: b***************--
--************************************************--
node b(clock, e1, e3 :int) returns (nextClock, e1_C, e3_C, e2_P :int; Fa: int );

var
Ea: int;
stage :int;
 laststage  :int;
Ta1, Ea1 : int; 
Ta2, Ea2 : int; 
let
Fa= if bDoFire(e1, e3,2) then 2
		else if bDoFire(e1, e3,1) then 1
		else 0;

(e1_C, e3_C) = ((Fa * b_e1_rate_in), (Fa * b_e3_rate_in));

stage = (if (Fa = 0) then 0 
         else   1) 
 -> if (Fa = 0) then 0 
         else if (pre laststage = b_maxstages) then  1 
         else  (pre laststage + 1) ; 
 
laststage = (if (Fa = 0) then 0 
         else   1) 
 -> if (Fa = 0) then (pre laststage) 
         else stage; 
 

(Ta1, Ea1) =bstage(clock, stage, 1, Fa); 
(Ta2, Ea2) =bstage(clock, stage, 2, Fa); 
 
 Ea = ( Ea1 + Ea2);
 
(e2_P) = ((Ea * b_e2_rate_out));

 nextClock= Min(Ta1 , Ta2);
 

tel;
------------------subnode DofTaire of Actorb-----------------
node bDoFire(e1, e3,times:int) returns ( yes: bool);
let

yes = if (e1>=  (times * b_e1_rate_in)) 
	and (e3>=  (times * b_e3_rate_in)) 
	then true 
	else false;

tel;
------------------subnode stage of Actorb-----------------
node bstage(clock,  stage, numstage, Fa : int) returns (Ta, Ea : int);

var 
Ea_ : int; 
selected, Ca, Ra : bool; 

 let
 selected = if  (stage = numstage) then true else false ; 
 
 Ca= false -> if not pre (Ra)  then false else pre  ((Ta - clock) = 0); 


 Ra = if  selected then true else false -> 
           if  selected then true 
         else if  Ca then false else pre Ra; 

 Ea_ = if selected then Fa  else 0 -> 
                        if selected then  Fa  else if Ca then 0 else pre Ea_ ; 

 Ea = 0 -> if Ca then pre Ea_ else 0; 

 Ta = if  selected then b_duration  else maxDuration -> 
          if  selected then b_duration 
          else if  (pre Ra) then if  (pre (Ta > clock) )then  pre (Ta - clock) 
          else maxDuration   else maxDuration ; 

 tel; 


--************************************************--
--******* Translation of Actor: c***************--
--************************************************--
node c(clock, e2, e5in :int) returns (nextClock, e2_C, e5in_C, e5out_P, e3_P, e4_P :int; Fa: int );

var
Ea: int;
let
Fa= if cDoFire(e2, e5in,1) then 1
		else 0;

(e2_C, e5in_C) = ((Fa * c_e2_rate_in), (Fa * c_e5in_rate_in));

Ea = 0 -> pre Fa  ;
(e5out_P, e3_P, e4_P) = ((Ea * c_e5out_rate_out), (Ea * c_e3_rate_out), (Ea * c_e4_rate_out));

nextClock = if (Fa = 0) then maxDuration else 1;
tel;
------------------subnode Dofire of Actorc-----------------
node cDoFire(e2, e5in,times:int) returns ( yes: bool);
let

yes = if (e2>=  (times * c_e2_rate_in)) 
	and (e5in>=  (times * c_e5in_rate_in)) 
	then true 
	else false;

tel;
--******* Node Min***************--
node Min (x, y :int) returns ( r: int);
let
r= if  (x < y) then x else y;
tel;

--************************************************--
--******* Node Top***************--
--************************************************--
node top (_: bool) returns ( clock, e1, e2, e3, e4, e5, aFa, bFa, cFa:int);

var

e1_C, e1_P: int; 
e2_C, e2_P: int; 
e3_C, e3_P: int; 
e4_C, e4_P: int; 
e5_C, e5_P: int; 
anextClock : int;  
bnextClock : int;  
cnextClock : int;  
positiveValues: bool; 

let

e1 = e1_I ->  ( pre ( e1 - e1_C) + e1_P);
e2 = e2_I ->  ( pre ( e2 - e2_C) + e2_P);
e3 = e3_I ->  ( pre ( e3 - e3_C) + e3_P);
e4 = e4_I ->  ( pre ( e4 - e4_C) + e4_P);
e5 = e5_I ->  ( pre ( e5 - e5_C) + e5_P);




(anextClock, e4_C, e1_P, aFa) = a(clock, e4);
(bnextClock, e1_C, e3_C, e2_P, bFa) = b(clock, e1, e3);
(cnextClock, e2_C, e5_C, e5_P, e3_P, e4_P, cFa) = c(clock, e2, e5);

clock= Min(anextClock , Min(bnextClock , cnextClock));



positiveValues = ( e1 >= 0) 
	and ( e2 >= 0) 
	and ( e3 >= 0) 
	and ( e4 >= 0) 
	and ( e5 >= 0) 
	and ( aFa  >=  0) 
	and ( bFa  >=  0) 
	and ( cFa  >=  0) ;
--%MAIN;

--%PROPERTY  "Ok, all variables are positive "  positiveValues;


tel;


