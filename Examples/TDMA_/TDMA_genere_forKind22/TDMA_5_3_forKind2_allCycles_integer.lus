--** This lustre code is generated automatically. 
--**It corresponds to a translation of SDFG model to Lustre. This version produce a code that simulates each clock cycle of the SDFG.  
--     27 mai 2020 04:02:53 PM




--**************** Const Rates ****************--

const maxValue = 15 ;
const A_e1_rate_in = 1;
const A_e3in_rate_in = 1;
const A_e3out_rate_out = 1;
const A_e4_rate_out = 1;
const A1_e4_rate_in = 1;
const A1_e2_rate_out = 1;

--**************** Init Channel ****************--

const e3_I = 5 ;
const e4_I = 0 ;

const e1_I = 0 ;
const e2_I = 0 ;

--**************** Actors Translation ****************--

node A(e1, e3in :int) returns (e1_C, e3in_C, e3out_P, e4_P :int; AnbrFired: int );

var
e3out_PD, e4_PD : int;
let
AnbrFired= if ADoFire(e1, e3in,5) then 5
		else if ADoFire(e1, e3in,4) then 4
		else if ADoFire(e1, e3in,3) then 3
		else if ADoFire(e1, e3in,2) then 2
		else if ADoFire(e1, e3in,1) then 1
		else 0;

(e1_C, e3in_C,e3out_PD, e4_PD) = ((AnbrFired * A_e1_rate_in), (AnbrFired * A_e3in_rate_in), (AnbrFired * A_e3out_rate_out), (AnbrFired * A_e4_rate_out));

e3out_P = 0 -> pre (0 -> pre (0 -> pre (0 -> pre (e3out_PD))));

e4_P = 0 -> pre (0 -> pre (0 -> pre (0 -> pre (e4_PD))));


tel;
------------------
node ADoFire(e1, e3in :int; times: int) returns ( yes: bool);
let

yes = if  (e1>=  (times * A_e1_rate_in)) 
	and  (e3in>=  (times * A_e3in_rate_in)) 
	then true 
	else false;

tel;
------------------
node A1(e4 :int) returns (e4_C, e2_P :int; A1nbrFired: int );

var
e2_PD : int;
let
A1nbrFired= if A1DoFire(e4,6) then 6
		else if A1DoFire(e4,5) then 5
		else if A1DoFire(e4,4) then 4
		else if A1DoFire(e4,3) then 3
		else if A1DoFire(e4,2) then 2
		else if A1DoFire(e4,1) then 1
		else 0;

(e4_C,e2_PD) = ((A1nbrFired * A1_e4_rate_in), (A1nbrFired * A1_e2_rate_out));

e2_P = 0 -> pre (0 -> pre (e2_PD));


tel;
------------------
node A1DoFire(e4 :int; times: int) returns ( yes: bool);
let

yes = if  (e4>=  (times * A1_e4_rate_in)) 
	then true 
	else false;

tel;
------------------
------------------
node top (e1_P: int) returns (e3, e4, e1, e2, AnbrFired, A1nbrFired: int);

-------------- Les variables -------------- 

var

e3_C, e3_P: int; 
e4_C, e4_P: int; 
e1_C : int;
e2_P : int;
--e1_P : int;
--n :int;

Sx, Sy, Te1: int; 

let


e1= e1_I -> pre ( e1-e1_C+ e1_P);
Te1= 0->pre (Te1 +e1_P);
e2 = e2_I -> pre (e2+ e2_P);
e3 = e3_I -> pre  (  ( e3-e3_C)+ e3_P);
e4 = e4_I -> pre  (  ( e4-e4_C)+ e4_P);
(e1_C, e3_C, e3_P, e4_P, AnbrFired) = A(e1, e3);
(e4_C, e2_P, A1nbrFired) = A1(e4);

Sx= 0-> pre (0-> pre (0-> pre (0-> pre (0-> pre e2)))); --P
Sy= 0-> pre (0-> pre (0-> pre (0-> pre (0-> pre (0-> pre (0-> pre (0-> pre Te1)))))));--P+N

--***************l'input se fait soit avec assert soit sans assert
--assert (e1_P >=0 and e1_P <=3);
assert (e1_P =20);

--n=1-> if ( pre n=20) then 0 else (pre n +1);
--e1_P=n;
--**************************
--%MAIN;

--%PROPERTY  "P1"  (e2-Sx) <=5;--  N!!!!
--%PROPERTY  "P2"  (e2<=Sy);
--%PROPERTY  "P3"  true-> not (e2 = pre e2)=> ((e2-Sx)=5 or (e2= Sy)); ---N!!!


tel;

