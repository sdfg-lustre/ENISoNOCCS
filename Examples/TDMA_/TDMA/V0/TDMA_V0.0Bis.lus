include "../BitBlasting/toInclude_BitBlasting_ok.lus"



--------------instruction with --------------------
--node P(const n: int; B: bool^n) returns (p:bool);
--let
-- p = with n=1 then B[0]
--      else XOR(B[n-1] , P(n-1,B[0..n-2]));
--tel



------------------------------SDFG weights
const IN_X=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];	const OUT_X=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; const X0=[0 , 0 , 0 , 0,  0 , 0  ,0  ,0]; 
const IN_Y=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];	const OUT_Y=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; const Y0=[0 , 0 , 0 , 0,  0 , 0  ,0  ,0];
const IN_Z=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];	const OUT_Z=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; const Z0=[0 , 0 , 0 , 0,  0 , 0  ,0  ,0];
const IN_V=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];	const OUT_V=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; const V0=[1 , 1 , 0 , 0,  0 , 0  ,0  ,0];

const IN_A=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; const A0=[0, 0 , 0 , 0,  0 , 0  ,0  ,0];
const IN_B=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0];     const OUT_B=[1 , 0 , 0 , 0,  0 , 0  ,0  ,0]; const B0=[0, 0,  0 , 0,  0 , 0  ,0  ,0];




--*******************node start*****************************************************

node Start (A: UsrInt) returns ( prodX, prodY : UsrInt;  StartFired: bool);
let

StartFired =UsrIntGte (A, IN_A) ;

(prodX, prodY) =	if 	StartFired then (A,A) else  (UsrInt_0, UsrInt_0) ;

--(prodX, prodY) =	if 	DoFireStart (A,UsrInt_4) then FireStart (UsrInt_4) 
--			else if DoFireStart (A,UsrInt_3) then FireStart (UsrInt_3) 
--			else if DoFireStart (A,UsrInt_2) then FireStart (UsrInt_2)  
--			else if DoFireStart (A,UsrInt_1) then FireStart (UsrInt_1) 
--			else 					FireStart (UsrInt_0);
tel



--******************node Ta******************************************************

node Ta (X, V: UsrInt) returns ( consX, consV, prodV, prodZ:UsrInt;  TaFired:bool);
let

TaFired =UsrIntGte (X, IN_X) and UsrIntGte (V, IN_V);
(consX, consV, prodV, prodZ) =	if 	DoFireTa (X,V,UsrInt_4) then FireTa (UsrInt_4) 
				else if DoFireTa (X,V,UsrInt_3) then FireTa (UsrInt_3) 
				else if DoFireTa (X,V,UsrInt_2) then FireTa (UsrInt_2)  
				else if DoFireTa (X,V,UsrInt_1) then FireTa (UsrInt_1) 
				else 					FireTa (UsrInt_0);
tel

----
node DoFireTa (X, V, times:UsrInt) returns ( yes: bool);
let
yes = if UsrIntGte (X, FourBitsMult(times, IN_X)) and 
	 UsrIntGte (V, FourBitsMult(times, IN_V)) then true 
	else false;
tel
---

node FireTa (times:UsrInt) returns (consX, consV, prodV, prodZ: UsrInt);
let
consX= FourBitsMult(times, IN_X) ;
consV= FourBitsMult(times, IN_V);
prodV= FourBitsMult(times,OUT_V) ;
prodZ= FourBitsMult(times,OUT_Z) ;
tel
----

--*****************node Ta1*******************************************************
 node Ta1 (Z: UsrInt) returns (consZ, prodB:UsrInt;  Ta1Fired:bool);
let

Ta1Fired =UsrIntGte (Z, IN_Z) ;
(consZ, prodB) =	if 	DoFireTa1 (Z, UsrInt_4)  then FireTa1 (UsrInt_4) 
				else if DoFireTa1 (Z, UsrInt_3) then FireTa1 (UsrInt_3) 
				else if DoFireTa1 (Z,  UsrInt_2) then FireTa1 (UsrInt_2)  
				else if DoFireTa1 (Z,  UsrInt_1) then FireTa1 (UsrInt_1) 
				else 					FireTa1 (UsrInt_0);
tel

----
node DoFireTa1 (Z, times:UsrInt) returns ( yes: bool);
let
yes = if UsrIntGte (Z, FourBitsMult(times, IN_Z)) then true 
	else false;
tel
---

node FireTa1 (times:UsrInt) returns (consZ,  prodB: UsrInt);
let
consZ= FourBitsMult(times, IN_Z) ;
prodB= FourBitsMult(times,OUT_B) ;
tel
----

--********************top****************************************************
node top (A:UsrInt) returns (  noErreur: bool );
--delayedV, delayedZ,

var  prodX, consX, prodY,  prodZ,  prodV, prodB, 
consZ, delayedZ , consV, delayedV,        delayedB, 
  Z, V,     X1, Y1, Z1, V1,  B1: UsrInt;
X: UsrInt;

endFiringTa1:  bool;
--nbrRuningTA: UsrInt;
Y_earlyTaTa1, B_earlyTa: UsrInt;

Ta1Fired, StartFired, TaFired : bool;
Y, B: UsrInt;
let


(prodX, prodY, StartFired) =  Start (A);


(consX, consV,   delayedV, delayedZ, TaFired) = Ta(X,V);
--si delai du noeud est X cycles alors il faut X-1 "pre"
-- delai de Ta== 5
 prodV= UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre delayedV)))))));
prodZ= UsrInt_0->  (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre delayedZ)))))));

(consZ,  delayedB, Ta1Fired)= Ta1(Z);
--si delai du noeud est X cycles alors il faut X-1 "pre"
--delai Ta1= 2
  prodB= UsrInt_0-> (pre delayedB);
 

--------
X1= UsrIntPlus (UsrIntMinus (X, consX), prodX);   X= X0-> (pre X1);
Y1= UsrIntPlus (Y, prodY);   Y= Y0-> (pre Y1);
Z1= UsrIntPlus (UsrIntMinus (Z, consZ), prodZ);   Z= Z0-> (pre Z1);
V1= UsrIntPlus (UsrIntMinus (V, consV), prodV);     V= V0-> (pre V1);
B1= UsrIntPlus (B, prodB);       B= B0-> (pre B1);



-- les signaux suivants ajoutés pour la vérification du modele
--enFiringTa vaut true qd Ta1 se termine; 
--si le delai de Ta1 est X alors il faut X pre dans endFiringTa ( et X-1)
--Delai Ta1= 2
endFiringTa1= false-> (pre (false->  (pre Ta1Fired)));

--si delai du noeud est X cycles alors il faut X "pre"
--delai Ta 5
 B_earlyTa= UsrInt_0->(pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre B)))))))));

--delai Ta + ta1= 7
Y_earlyTaTa1= UsrInt_0->(pre  (UsrInt_0->(pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre (UsrInt_0-> (pre Y)))))))))))));

--noErreur= ( not endFiringTa1 ) ;
--noErreur1= ( not endFiringTa1 ) ;
--noErreur2=  UsrIntEq(UsrIntMinus(B, B_earlyTa), V0) ;
--noErreur3=   UsrIntEq(B, Y_earlyTaTa1);
noErreur=  ( not endFiringTa1 ) or UsrIntEq(UsrIntMinus(B, B_earlyTa), V0) or  UsrIntEq(B, Y_earlyTaTa1);
assert UsrIntLte(A, UsrInt_1)   ;


tel

 

