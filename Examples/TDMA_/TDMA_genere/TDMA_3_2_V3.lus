include "./toInclude_BitBlasting_ok.lus"

const maxValue = [1,1,1,1,0,0,0,0];

--**************** Const Rates ****************--

const A_Y_rate_in = [1,0,0,0,0,0,0,0];
const A_Vin_rate_in = [1,0,0,0,0,0,0,0];
const A_Vout_rate_out = [1,0,0,0,0,0,0,0];
const A_Z_rate_out = [1,0,0,0,0,0,0,0];
const A1_Z_rate_in = [1,0,0,0,0,0,0,0];
const A1_B_rate_out = [1,0,0,0,0,0,0,0];
const A1_B1_rate_out = [1,0,0,0,0,0,0,0];
const A1_B2_rate_out = [1,0,0,0,0,0,0,0];
const G_In_rate_in = [1,0,0,0,0,0,0,0];
const G_X_rate_out = [1,0,0,0,0,0,0,0];
const G_Y_rate_out = [1,0,0,0,0,0,0,0];
const P_X_rate_in = [1,0,0,0,0,0,0,0];
const P_B_rate_in = [1,0,0,0,0,0,0,0];
const P2_B1_rate_in = [1,0,0,0,0,0,0,0];
const P2_B2_rate_in = [1,0,0,0,0,0,0,0];

--****************  Actor'durations ****************--

const A_duration  = [1,1,0,0,0,0,0,0];
const A1_duration  = [0,1,0,0,0,0,0,0];
const G_duration  = [1,0,0,0,0,0,0,0];
const P_duration  = [1,0,0,0,0,0,0,0];
const P2_duration  = [1,0,0,0,0,0,0,0];
const  maxDuration  = [1,1,0,0,0,0,0,0];

--**************** Init Channel ****************--

const X_I = [0,0,0,0,0,0,0,0];
const Y_I = [0,0,0,0,0,0,0,0];
const V_I = [1,1,0,0,0,0,0,0];
const Z_I = [0,0,0,0,0,0,0,0];
const B_I = [0,0,0,0,0,0,0,0];
const B1_I = [0,0,0,0,0,0,0,0];
const B2_I = [0,0,0,0,0,0,0,0];

const In_I = [0,0,0,0,0,0,0,0];

--************************************************--
--******* Translation of Actor: A***************--
--************************************************--
node A(clock, Y, Vin :UsrInt) returns (nextClock, Y_C, Vin_C, Vout_P, Z_P :UsrInt; AnbrFired: UsrInt );

var
stage  :UsrInt;
Vout_PD, Z_PD :UsrInt;
rTime1, Vout_P1, Z_P1 : UsrInt; 
rTime2, Vout_P2, Z_P2 : UsrInt; 
rTime3, Vout_P3, Z_P3 : UsrInt; 
let
AnbrFired= if ADoFire(Y, Vin,UsrInt_3) then UsrInt_3
		else if ADoFire(Y, Vin,UsrInt_2) then UsrInt_2
		else if ADoFire(Y, Vin,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(Y_C, Vin_C,Vout_PD, Z_PD) = (UsrIntMult(AnbrFired, A_Y_rate_in),UsrIntMult(AnbrFired, A_Vin_rate_in),UsrIntMult(AnbrFired, A_Vout_rate_out),UsrIntMult(AnbrFired, A_Z_rate_out));

stage = (if UsrIntEq(AnbrFired, UsrInt_0) then UsrInt_0 
         else   UsrInt_1) 
 -> if UsrIntEq(AnbrFired, UsrInt_0) then UsrInt_0 
         else if UsrIntEq(pre last, maxStages) then  UsrInt_1 
         else UsrIntPlus (pre last, UsrInt_1) ; 
 
last = (if UsrIntEq(AnbrFired, UsrInt_0) then UsrInt_0 
         else   UsrInt_1) 
 -> if UsrIntEq(AnbrFired, UsrInt_0) then (pre last) 
         else stage; 
 

(rTime1, Vout_P1, Z_P1)=AStage(clock, stage, UsrInt_1, Vout_PD, Z_PD); 
(rTime2, Vout_P2, Z_P2)=AStage(clock, stage, UsrInt_2, Vout_PD, Z_PD); 
(rTime3, Vout_P3, Z_P3)=AStage(clock, stage, UsrInt_3, Vout_PD, Z_PD); 

 nextClock= UsrIntMin(rTime1, UsrIntMin(rTime2, rTime3));
 
Vout_P = UsrIntPlus(Vout_P1, UsrIntPlus(Vout_P2, Vout_P3));
Z_P = UsrIntPlus(Z_P1, UsrIntPlus(Z_P2, Z_P3));

tel;
------------------subnode Dofire of ActorA-----------------
node ADoFire(Y, Vin,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(Y, UsrIntMult(times, A_Y_rate_in)) 
	and UsrIntGte(Vin, UsrIntMult(times, A_Vin_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of ActorA-----------------
node AStage(clock,  stage, numStage, Vout_PD, Z_PD: UstInt) returns (rTime, Vout_P, Z_P : UsrInt);

var 
Vout_PDBuffer, Z_PDBuffer, rsteps  : UsrInt; 
active : bool; 

 let 
active = if  UsrIntEq(stage, numStage) then true 
         else if  (pre active) and UsrIntEq(UsrIntMinus(pre rTime, clock), UsrInt_0) then false 
              else pre active; 
rTime = if  UsrIntEq(stage, numStage) then A_duration 
         else if  (pre active) then UsrIntMinus(pre rTime, clock) 
             else maxDuration ; 
(Vout_PDBuffer, Z_PDBuffer) =  if  UsrIntEq(stage, numStage) then (Vout_PD, Z_PD) 
                               else if (pre active) and UsrIntEq(UsrIntMinus(pre rTime, clock), UsrInt_0) then (0, 0)
                                        else ( pre Vout_PDBuffer, pre Z_PDBuffer); 
(Vout_P, Z_P) =   if (pre active) and UsrIntEq(UsrIntMinus(pre rTime, clock), UsrInt_0) then (Vout_PDBuffer, Z_PDBuffer)
                                        else (0, 0)
tel; 


--************************************************--
--******* Translation of Actor: A1***************--
--************************************************--
node A1(clock, Z :UsrInt) returns (nextClock, Z_C, B_P, B1_P, B2_P :UsrInt; A1nbrFired: UsrInt );

var
stage  :UsrInt;
B_PD, B1_PD, B2_PD :UsrInt;
rTime1, B_P1, B1_P1, B2_P1 : UsrInt; 
rTime2, B_P2, B1_P2, B2_P2 : UsrInt; 
let
A1nbrFired= if A1DoFire(Z,UsrInt_3) then UsrInt_3
		else if A1DoFire(Z,UsrInt_2) then UsrInt_2
		else if A1DoFire(Z,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(Z_C,B_PD, B1_PD, B2_PD) = (UsrIntMult(A1nbrFired, A1_Z_rate_in),UsrIntMult(A1nbrFired, A1_B_rate_out),UsrIntMult(A1nbrFired, A1_B1_rate_out),UsrIntMult(A1nbrFired, A1_B2_rate_out));

stage = (if UsrIntEq(A1nbrFired, UsrInt_0) then UsrInt_0 
         else   UsrInt_1) 
 -> if UsrIntEq(A1nbrFired, UsrInt_0) then UsrInt_0 
         else if UsrIntEq(pre last, maxStages) then  UsrInt_1 
         else UsrIntPlus (pre last, UsrInt_1) ; 
 
last = (if UsrIntEq(A1nbrFired, UsrInt_0) then UsrInt_0 
         else   UsrInt_1) 
 -> if UsrIntEq(A1nbrFired, UsrInt_0) then (pre last) 
         else stage; 
 

(rTime1, B_P1, B1_P1, B2_P1)=A1Stage(clock, stage, UsrInt_1, B_PD, B1_PD, B2_PD); 
(rTime2, B_P2, B1_P2, B2_P2)=A1Stage(clock, stage, UsrInt_2, B_PD, B1_PD, B2_PD); 

 nextClock= UsrIntMin(rTime1, rTime2);
 
B_P = UsrIntPlus(B_P1, B_P2);
B1_P = UsrIntPlus(B1_P1, B1_P2);
B2_P = UsrIntPlus(B2_P1, B2_P2);

tel;
------------------subnode Dofire of ActorA1-----------------
node A1DoFire(Z,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(Z, UsrIntMult(times, A1_Z_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of ActorA1-----------------
node A1Stage(clock,  stage, numStage, B_PD, B1_PD, B2_PD: UstInt) returns (rTime, B_P, B1_P, B2_P : UsrInt);

var 
B_PDBuffer, B1_PDBuffer, B2_PDBuffer, rsteps  : UsrInt; 
active : bool; 

 let 
active = if  UsrIntEq(stage, numStage) then true 
         else if  (pre active) and UsrIntEq(UsrIntMinus(pre rTime, clock), UsrInt_0) then false 
              else pre active; 
rTime = if  UsrIntEq(stage, numStage) then A1_duration 
         else if  (pre active) then UsrIntMinus(pre rTime, clock) 
             else maxDuration ; 
(B_PDBuffer, B1_PDBuffer, B2_PDBuffer) =  if  UsrIntEq(stage, numStage) then (B_PD, B1_PD, B2_PD) 
                               else if (pre active) and UsrIntEq(UsrIntMinus(pre rTime, clock), UsrInt_0) then (0, 0, 0)
                                        else ( pre B_PDBuffer, pre B1_PDBuffer, pre B2_PDBuffer); 
(B_P, B1_P, B2_P) =   if (pre active) and UsrIntEq(UsrIntMinus(pre rTime, clock), UsrInt_0) then (B_PDBuffer, B1_PDBuffer, B2_PDBuffer)
                                        else (0, 0, 0)
tel; 


--************************************************--
--******* Translation of Actor: G***************--
--************************************************--
node G(clock, In :UsrInt) returns (nextClock, In_C, X_P, Y_P :UsrInt; GnbrFired: UsrInt );

let
GnbrFired= if GDoFire(In,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(In_C,X_P, Y_P) = (UsrIntMult(GnbrFired, G_In_rate_in),UsrIntMult(GnbrFired, G_X_rate_out),UsrIntMult(GnbrFired, G_Y_rate_out));

nextClock = if UsrIntEq(GnbrFired, UsrInt_0) then maxDuration else UsrInt_1;
tel;
------------------subnode Dofire of ActorG-----------------
node GDoFire(In,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(In, UsrIntMult(times, G_In_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: P***************--
--************************************************--
node P(clock, X, B :UsrInt) returns (nextClock, X_C, B_C :UsrInt; PnbrFired: UsrInt );

let
PnbrFired= if PDoFire(X, B,UsrInt_5) then UsrInt_5
		else if PDoFire(X, B,UsrInt_4) then UsrInt_4
		else if PDoFire(X, B,UsrInt_3) then UsrInt_3
		else if PDoFire(X, B,UsrInt_2) then UsrInt_2
		else if PDoFire(X, B,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(X_C, B_C,) = (UsrIntMult(PnbrFired, P_X_rate_in),UsrIntMult(PnbrFired, P_B_rate_in));

nextClock = if UsrIntEq(PnbrFired, UsrInt_0) then maxDuration else UsrInt_1;
tel;
------------------subnode Dofire of ActorP-----------------
node PDoFire(X, B,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(X, UsrIntMult(times, P_X_rate_in)) 
	and UsrIntGte(B, UsrIntMult(times, P_B_rate_in)) 
	then true 
	else false;

tel;

--************************************************--
--******* Translation of Actor: P2***************--
--************************************************--
node P2(clock, B1, B2 :UsrInt) returns (nextClock, B1_C, B2_C :UsrInt; P2nbrFired: UsrInt );

let
P2nbrFired= if P2DoFire(B1, B2,UsrInt_5) then UsrInt_5
		else if P2DoFire(B1, B2,UsrInt_4) then UsrInt_4
		else if P2DoFire(B1, B2,UsrInt_3) then UsrInt_3
		else if P2DoFire(B1, B2,UsrInt_2) then UsrInt_2
		else if P2DoFire(B1, B2,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(B1_C, B2_C,) = (UsrIntMult(P2nbrFired, P2_B1_rate_in),UsrIntMult(P2nbrFired, P2_B2_rate_in));

nextClock = if UsrIntEq(P2nbrFired, UsrInt_0) then maxDuration else UsrInt_1;
tel;
------------------subnode Dofire of ActorP2-----------------
node P2DoFire(B1, B2,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(B1, UsrIntMult(times, P2_B1_rate_in)) 
	and UsrIntGte(B2, UsrIntMult(times, P2_B2_rate_in)) 
	then true 
	else false;

tel;
--******* Node UsrIntMin***************--
node UsrIntMin (x, y :UsrInt) returns ( r: UsrInt);
let
r= if usrIntLt (x, y) then x else y;
tel;

--************************************************--
--******* Node Top***************--
--************************************************--
node top (In_P: UsrInt) returns ( clock, X, Y, V, Z, B, B1, B2, In, AnbrFired, A1nbrFired, GnbrFired, PnbrFired, P2nbrFired:UsrInt);

var

X_C, X_P: UsrInt; 
Y_C, Y_P: UsrInt; 
V_C, V_P: UsrInt; 
Z_C, Z_P: UsrInt; 
B_C, B_P: UsrInt; 
B1_C, B1_P: UsrInt; 
B2_C, B2_P: UsrInt; 
In_C : UsrInt;
AnextClock : UsrInt;  
A1nextClock : UsrInt;  
GnextClock : UsrInt;  
PnextClock : UsrInt;  
P2nextClock : UsrInt;  

let

X = X_I -> pre UsrIntPlus( UsrIntMinus( X,X_C), X_P);
Y = Y_I -> pre UsrIntPlus( UsrIntMinus( Y,Y_C), Y_P);
V = V_I -> pre UsrIntPlus( UsrIntMinus( V,V_C), V_P);
Z = Z_I -> pre UsrIntPlus( UsrIntMinus( Z,Z_C), Z_P);
B = B_I -> pre UsrIntPlus( UsrIntMinus( B,B_C), B_P);
B1 = B1_I -> pre UsrIntPlus( UsrIntMinus( B1,B1_C), B1_P);
B2 = B2_I -> pre UsrIntPlus( UsrIntMinus( B2,B2_C), B2_P);

In = In_I -> pre if UsrIntLt(UsrIntPlus( UsrIntMinus( In,In_C), In_P), maxValue) 
				then UsrIntPlus( UsrIntMinus( In,In_C), In_P)
				else UsrIntMinus( In,In_C);


(AnextClock, Y_C, V_C, V_P, Z_P, AnbrFired) = A(clock, Y, V);
(A1nextClock, Z_C, B_P, B1_P, B2_P, A1nbrFired) = A1(clock, Z);
(GnextClock, In_C, X_P, Y_P, GnbrFired) = G(clock, In);
(PnextClock, X_C, B_C, PnbrFired) = P(clock, X, B);
(P2nextClock, B1_C, B2_C, P2nbrFired) = P2(clock, B1, B2);

clock= pre UsrIntMin(AnextClock, UsrIntMin(A1nextClock, UsrIntMin(GnextClock, UsrIntMin(PnextClock, P2nextClock))));



tel;



--************************************************--
--******* Node Harness***************--
--************************************************--
node Harness (In_P: UsrInt) returns (noError :bool)

var

X, Y, V, Z, B, B1, B2, In, AnbrFired, A1nbrFired, GnbrFired, PnbrFired, P2nbrFired:UsrInt;

positiveValues: bool;

let

(X, Y, V, Z, B, B1, B2, In, AnbrFired, A1nbrFired, GnbrFired, PnbrFired, P2nbrFired) = top(In_P);

positiveValues = UsrIntGte( X, UsrInt_0) 
	and UsrIntGte( Y, UsrInt_0) 
	and UsrIntGte( V, UsrInt_0) 
	and UsrIntGte( Z, UsrInt_0) 
	and UsrIntGte( B, UsrInt_0) 
	and UsrIntGte( B1, UsrInt_0) 
	and UsrIntGte( B2, UsrInt_0) 
	and UsrIntGte( In, UsrInt_0) 
	and UsrIntGte( AnbrFired , UsrInt_0) 
	and UsrIntGte( A1nbrFired , UsrInt_0) 
	and UsrIntGte( GnbrFired , UsrInt_0) 
	and UsrIntGte( PnbrFired , UsrInt_0) 
	and UsrIntGte( P2nbrFired , UsrInt_0) ;

noError= positiveValues and true;

tel
