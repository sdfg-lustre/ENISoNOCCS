--** This lustre code is generated automatically. 
--**It corresponds to a translation of SDFG model to Lustre. This version produce a code that simulates each clock cycle of the SDFG.  
--     27 mai 2020 01:02:26 PM




--**************** Const Rates ****************--

const maxValue = 15 ;
const A_e1_rate_in = 1;
const A_e3in_rate_in = 1;
const A_e3out_rate_out = 1;
const A_e4_rate_out = 1;
const A1_e4_rate_in = 1;
const A1_e2_rate_out = 1;

--**************** Init Channel ****************--

const e3_I = 3 ;
const e4_I = 0 ;

const e1_I = 0 ;
const e2_I = 0 ;

--**************** Actors Translation ****************--

node A(e1, e3in :int) returns (e1_C, e3in_C, e3out_P, e4_P :int; AnbrFired: int );

var
e3out_PD, e4_PD : int;
let
AnbrFired= if ADoFire(e1, e3in,3) then 3
		else if ADoFire(e1, e3in,2) then 2
		else if ADoFire(e1, e3in,1) then 1
		else 0;

(e1_C, e3in_C,e3out_PD, e4_PD) = ((AnbrFired * A_e1_rate_in), (AnbrFired * A_e3in_rate_in), (AnbrFired * A_e3out_rate_out), (AnbrFired * A_e4_rate_out));

e3out_P = 0 -> pre (0 -> pre (e3out_PD));

e4_P = 0 -> pre (0 -> pre (e4_PD));


tel;
------------------
node ADoFire(e1, e3in :int; times: int) returns ( yes: bool);
let

yes = if  (e1>=  (times * A_e1_rate_in)) 
	and  (e3in>=  (times * A_e3in_rate_in)) 
	then true 
	else false;

tel;
------------------
node A1(e4 :int) returns (e4_C, e2_P :int; A1nbrFired: int );

var
e2_PD : int;
let
A1nbrFired= if A1DoFire(e4,3) then 3
		else if A1DoFire(e4,2) then 2
		else if A1DoFire(e4,1) then 1
		else 0;

(e4_C,e2_PD) = ((A1nbrFired * A1_e4_rate_in), (A1nbrFired * A1_e2_rate_out));

e2_P = 0 -> pre (e2_PD);


tel;
------------------
node A1DoFire(e4 :int; times: int) returns ( yes: bool);
let

yes = if  (e4>=  (times * A1_e4_rate_in)) 
	then true 
	else false;

tel;
------------------
node top (e1_P: int) returns (e3, e4, e1, e2, AnbrFired, A1nbrFired: int);

-------------- Les variables -------------- 

var

e3_C, e3_P: int; 
e4_C, e4_P: int; 
e1_C : int;
e2_P : int;

let

e3 = e3_I -> pre  (  ( e3-e3_C)+ e3_P);
e4 = e4_I -> pre  (  ( e4-e4_C)+ e4_P);

e1 = e1_I -> pre if ((  ( e1-e1_C) + e1_P) <  maxValue) 
				then  (  ( e1-e1_C)+ e1_P)
				else  ( e1-e1_C);

e2 = e2_I -> pre if ((e2+ e2_P)< maxValue) 
				then (e2+ e2_P)
				else e2;

(e1_C, e3_C, e3_P, e4_P, AnbrFired) = A(e1, e3);
(e4_C, e2_P, A1nbrFired) = A1(e4);


tel;


--**************** Node Harness Declaration ****************--

node Harness (e1_P: int) returns (noError :bool)

var

e3, e4, e1, e2, AnbrFired, A1nbrFired: int;

positiveValues: bool;

let

(e3, e4, e1, e2, AnbrFired, A1nbrFired) =top(e1_P);

positiveValues = ( e3>=   0) 
	and  ( e4>=   0) 
	and  ( e1>=  0) 
	and  ( e2>=  0) 
	and  ( AnbrFired >= 0) 
	and  ( A1nbrFired >= 0) ;

noError= positiveValues ;

--%MAIN;

--%PROPERTY  "All variables are positive "  noError;

tel 

