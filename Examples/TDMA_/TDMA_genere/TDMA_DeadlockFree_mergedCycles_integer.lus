--** This lustre code is generated automatically. 
--** It corresponds to the translation of an SDFG model to Lustre. This version produce a Lustre code having a reduced number of steps.
--     27 mai 2020 12:57:00 PM




--**************** Const Rates ****************--

const maxValue = 15;
const A_Vin_rate_in = 1;
const A_Vout_rate_out = 1;
const A_Z_rate_out = 1;
const A1_Z_rate_in = 1;

--****************  Actors' durations ****************--

const A_maxStages  = 2;
const A_duration  = 3;
const A1_maxStages  = 2;
const A1_duration  = 2;
const  maxDuration  = 3;

--**************** Init Channel ****************--

const V_I = 3;
const Z_I = 0;


--************************************************--
--******* Translation of Actor: A***************--
--************************************************--
node A(clock, Vin :int) returns (nextClock, Vin_C, Vout_P, Z_P :int; AnbrFired: int );

var
Vout_PD, Z_PD :int;
stage :int;
 lastStage  :int;
rTime1, Vout_P1, Z_P1 : int; 
rTime2, Vout_P2, Z_P2 : int; 
let
AnbrFired= if ADoFire(Vin,3) then 3
		else if ADoFire(Vin,2) then 2
		else if ADoFire(Vin,1) then 1
		else 0;

(Vin_C, Vout_PD, Z_PD) = ((AnbrFired * A_Vin_rate_in),(AnbrFired * A_Vout_rate_out),(AnbrFired * A_Z_rate_out));

stage = (if (AnbrFired = 0) then 0 
         else   1) 
 -> if (AnbrFired = 0) then 0 
         else if (pre lastStage = A_maxStages) then  1 
         else  (pre lastStage + 1) ; 
 
lastStage = (if (AnbrFired = 0) then 0 
         else   1) 
 -> if (AnbrFired = 0) then (pre lastStage) 
         else stage; 
 

(rTime1, Vout_P1, Z_P1)=AStage(clock, stage, 1, Vout_PD, Z_PD); 
(rTime2, Vout_P2, Z_P2)=AStage(clock, stage, 2, Vout_PD, Z_PD); 

 nextClock= Min(rTime1 , rTime2);
 
Vout_P = (Vout_P1 + Vout_P2);
Z_P = (Z_P1 + Z_P2);

tel;
------------------subnode Dofire of ActorA-----------------
node ADoFire(Vin,times:int) returns ( yes: bool);
let

yes = if (Vin>=  (times * A_Vin_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of ActorA-----------------
node AStage(clock,  stage, numStage, Vout_PD, Z_PD: int) returns (rTime, Vout_P, Z_P : int);

var 
Vout_PDBuffer, Z_PDBuffer: int; 
selected, endExecution, active : bool; 

 let 
selected = if  (stage = numStage) then true else false ; 
 endExecution= false -> if not pre (active)  then false else pre  ((rTime - clock) = 0); 
active = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre active; 
rTime = if  selected then A_duration  else maxDuration -> 
          if  selected then A_duration 
          else if  (pre active) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 
(Vout_PDBuffer, Z_PDBuffer) = if selected then (Vout_PD, Z_PD) 
                               else (0, 0) 
 ->if selected then (Vout_PD, Z_PD) 
                               else if endExecution then (0, 0)
           else pre (Vout_PDBuffer, Z_PDBuffer); 
(Vout_P, Z_P) = (0, 0) ->   if endExecution then pre (Vout_PDBuffer, Z_PDBuffer)
                                        else (0, 0); 
tel; 


--************************************************--
--******* Translation of Actor: A1***************--
--************************************************--
node A1(clock, Z :int) returns (nextClock, Z_C :int; A1nbrFired: int );

let
A1nbrFired= if A1DoFire(Z,3) then 3
		else if A1DoFire(Z,2) then 2
		else if A1DoFire(Z,1) then 1
		else 0;

(Z_C) = ((A1nbrFired * A1_Z_rate_in));

nextClock = maxDuration ;
tel;
------------------subnode Dofire of ActorA1-----------------
node A1DoFire(Z,times:int) returns ( yes: bool);
let

yes = if (Z>=  (times * A1_Z_rate_in)) 
	then true 
	else false;

tel;
--******* Node Min***************--
node Min (x, y :int) returns ( r: int);
let
r= if  (x < y) then x else y;
tel;

--************************************************--
--******* Node Top***************--
--************************************************--
node top (_: bool) returns ( clock, V, Z, AnbrFired, A1nbrFired:int);

var

V_C, V_P: int; 
Z_C, Z_P: int; 
AnextClock : int;  
A1nextClock : int;  

let

V = V_I ->  ( pre ( V - V_C) + V_P);
Z = Z_I ->  ( pre ( Z - Z_C) + Z_P);



(AnextClock, V_C, V_P, Z_P, AnbrFired) = A(clock, V);
(A1nextClock, Z_C, A1nbrFired) = A1(clock, Z);

clock=  Min(AnextClock , A1nextClock);



tel;



--************************************************--
--******* Node Harness***************--
--************************************************--
node Harness (_: bool ) returns (noError :bool)

var
clock : int;

V, Z, AnbrFired, A1nbrFired:int;

positiveValues: bool;

let

(clock, V, Z, AnbrFired, A1nbrFired) =top(_); 

positiveValues = ( V >= 0) 
	and ( Z >= 0) 
	and ( AnbrFired  >=  0) 
	and ( A1nbrFired  >=  0) ;

noError= positiveValues;

--%MAIN;

--%PROPERTY  "All variables are positive "  noError;

tel 

