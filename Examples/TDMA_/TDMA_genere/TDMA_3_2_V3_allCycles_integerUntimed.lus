--** This lustre code is generated automatically. 
--**It corresponds to a translation of Untimed SDFG model to Lustre
--     26 mai 2020 03:26:19 PM



const maxValue = 15;

--**************** Const Rates ****************--

const A_Y_rate_in = 1 ;
const A_Vin_rate_in = 1 ;
const A_Vout_rate_out = 1 ;
const A_Z_rate_out = 1 ;
const A1_Z_rate_in = 1 ;
const A1_B_rate_out = 1 ;
const A1_B1_rate_out = 1 ;
const A1_B2_rate_out = 1 ;
const G_In_rate_in = 1 ;
const G_X_rate_out = 1 ;
const G_Y_rate_out = 1 ;
const P_X_rate_in = 1 ;
const P_B_rate_in = 1 ;
const P2_B1_rate_in = 1 ;
const P2_B2_rate_in = 1 ;

--**************** Init Channel ****************--

const X_I = 0 ;
const Y_I = 0 ;
const V_I = 3 ;
const Z_I = 0 ;
const B_I = 0 ;
const B1_I = 0 ;
const B2_I = 0 ;

const In_I = 0

--**************** Nodes Declaration ****************--

node A(Y, Vin :int) returns (Y_C, Vin_C, Vout_P, Z_P :int; AnbrFired: int );

let
AnbrFired= if ADoFire(Y, Vin,3) then 3
		else if ADoFire(Y, Vin,2) then 2
		else if ADoFire(Y, Vin,1) then 1
		else 0;

(Y_C, Vin_C,Vout_P, Z_P) = ((AnbrFired * A_Y_rate_in), (AnbrFired * A_Vin_rate_in), (AnbrFired * A_Vout_rate_out), (AnbrFired * A_Z_rate_out));

tel;
------------------
node ADoFire(Y, Vin :int; times: int) returns ( yes: bool);
let

yes = if  (Y>=  (times * A_Y_rate_in)) 
	and  (Vin>=  (times * A_Vin_rate_in)) 
	then true 
	else false;

tel;
------------------
node A1(Z :int) returns (Z_C, B_P, B1_P, B2_P :int; A1nbrFired: int );

let
A1nbrFired= if A1DoFire(Z,3) then 3
		else if A1DoFire(Z,2) then 2
		else if A1DoFire(Z,1) then 1
		else 0;

(Z_C,B_P, B1_P, B2_P) = ((A1nbrFired * A1_Z_rate_in), (A1nbrFired * A1_B_rate_out), (A1nbrFired * A1_B1_rate_out), (A1nbrFired * A1_B2_rate_out));

tel;
------------------
node A1DoFire(Z :int; times: int) returns ( yes: bool);
let

yes = if  (Z>=  (times * A1_Z_rate_in)) 
	then true 
	else false;

tel;
------------------
node G(In :int) returns (In_C, X_P, Y_P :int; GnbrFired: int );

let
GnbrFired= if GDoFire(In,1) then 1
		else 0;

(In_C,X_P, Y_P) = ((GnbrFired * G_In_rate_in), (GnbrFired * G_X_rate_out), (GnbrFired * G_Y_rate_out));

tel;
------------------
node GDoFire(In :int; times: int) returns ( yes: bool);
let

yes = if  (In>=  (times * G_In_rate_in)) 
	then true 
	else false;

tel;
------------------
node P(X, B :int) returns (X_C, B_C :int; PnbrFired: int );

let
PnbrFired= if PDoFire(X, B,5) then 5
		else if PDoFire(X, B,4) then 4
		else if PDoFire(X, B,3) then 3
		else if PDoFire(X, B,2) then 2
		else if PDoFire(X, B,1) then 1
		else 0;

(X_C, B_C) = ((PnbrFired * P_X_rate_in), (PnbrFired * P_B_rate_in));

tel;
------------------
node PDoFire(X, B :int; times: int) returns ( yes: bool);
let

yes = if  (X>=  (times * P_X_rate_in)) 
	and  (B>=  (times * P_B_rate_in)) 
	then true 
	else false;

tel;
------------------
node P2(B1, B2 :int) returns (B1_C, B2_C :int; P2nbrFired: int );

let
P2nbrFired= if P2DoFire(B1, B2,5) then 5
		else if P2DoFire(B1, B2,4) then 4
		else if P2DoFire(B1, B2,3) then 3
		else if P2DoFire(B1, B2,2) then 2
		else if P2DoFire(B1, B2,1) then 1
		else 0;

(B1_C, B2_C) = ((P2nbrFired * P2_B1_rate_in), (P2nbrFired * P2_B2_rate_in));

tel;
------------------
node P2DoFire(B1, B2 :int; times: int) returns ( yes: bool);
let

yes = if  (B1>=  (times * P2_B1_rate_in)) 
	and  (B2>=  (times * P2_B2_rate_in)) 
	then true 
	else false;

tel;
------------------

--**************** Node Top Declaration ****************--

node top (In_P: int) returns (X, Y, V, Z, B, B1, B2, In, AnbrFired, A1nbrFired, GnbrFired, PnbrFired, P2nbrFired: int);

var

X_C, X_P: int; 
Y_C, Y_P: int; 
V_C, V_P: int; 
Z_C, Z_P: int; 
B_C, B_P: int; 
B1_C, B1_P: int; 
B2_C, B2_P: int; 
In_C : int;

let

X = X_I -> pre  (  ( X-X_C)+ X_P);
Y = Y_I -> pre  (  ( Y-Y_C)+ Y_P);
V = V_I -> pre  (  ( V-V_C)+ V_P);
Z = Z_I -> pre  (  ( Z-Z_C)+ Z_P);
B = B_I -> pre  (  ( B-B_C)+ B_P);
B1 = B1_I -> pre  (  ( B1-B1_C)+ B1_P);
B2 = B2_I -> pre  (  ( B2-B2_C)+ B2_P);

In = In_I -> pre if ( (  ( In-In_C)+ In_P)< maxValue) 
				then  (  ( In-In_C)+ In_P)
				else  ( In-In_C);


(Y_C, V_C, V_P, Z_P, AnbrFired) = A(Y, V);
(Z_C, B_P, B1_P, B2_P, A1nbrFired) = A1(Z);
(In_C, X_P, Y_P, GnbrFired) = G(In);
(X_C, B_C, PnbrFired) = P(X, B);
(B1_C, B2_C, P2nbrFired) = P2(B1, B2);


tel;


--**************** Node Harness Declaration ****************--

node Harness (In_P: int) returns (noError :bool)

var

X, Y, V, Z, B, B1, B2, In, AnbrFired, A1nbrFired, GnbrFired, PnbrFired, P2nbrFired: int;

noDeadlock : bool;

let

(X, Y, V, Z, B, B1, B2, In, AnbrFired, A1nbrFired, GnbrFired, PnbrFired, P2nbrFired)=top(In_P);

noDeadlock = ( AnbrFired >= 1) 
	or  ( A1nbrFired >= 1) 
	or  ( GnbrFired >= 1) 
	or  ( PnbrFired >= 1) 
	or  ( P2nbrFired >= 1);
--%MAIN;

--%PROPERTY  "Deadlock free "  noDeadlock;

tel 

