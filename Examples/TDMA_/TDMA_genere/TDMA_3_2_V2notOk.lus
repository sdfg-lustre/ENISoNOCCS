-- la compilation avec lustre V4 marche mais la construction du bdd  prend un temps infini
-- la compilation avec lustre V6 produit une erreur due au fichier toInclude_BitBlasting_ok.lus

include "./toInclude_BitBlasting_ok.lus"

const maxValue = [1,1,1,1,0,0,0,0];

--**************** Const Rates ****************--

const A_Y_rate_in = [1,0,0,0,0,0,0,0];
const A_Vin_rate_in = [1,0,0,0,0,0,0,0];
const A_Vout_rate_out = [1,0,0,0,0,0,0,0];
const A_Z_rate_out = [1,0,0,0,0,0,0,0];
const A1_Z_rate_in = [1,0,0,0,0,0,0,0];
const A1_B_rate_out = [1,0,0,0,0,0,0,0];
const A1_B1_rate_out = [1,0,0,0,0,0,0,0];
const A1_B2_rate_out = [1,0,0,0,0,0,0,0];
const P_X_rate_in = [1,0,0,0,0,0,0,0];
const P_B_rate_in = [1,0,0,0,0,0,0,0];
const P2_B1_rate_in = [1,0,0,0,0,0,0,0];
const P2_B2_rate_in = [1,0,0,0,0,0,0,0];

--**************** Init Channel ****************--

const V_I = [1,1,0,0,0,0,0,0];
const Z_I = [0,0,0,0,0,0,0,0];
const B_I = [0,0,0,0,0,0,0,0];
const B1_I = [0,0,0,0,0,0,0,0];
const B2_I = [0,0,0,0,0,0,0,0];

const X_I = [0,0,0,0,0,0,0,0];
const Y_I = [0,0,0,0,0,0,0,0];

--**************** Nodes Declaration ****************--

node A(Y, Vin :UsrInt) returns (Y_C, Vin_C, Vout_P, Z_P :UsrInt; AnbrFired: UsrInt );

var
Vout_PD, Z_PD :UsrInt;
let
AnbrFired= if ADoFire(Y, Vin,UsrInt_3) then UsrInt_3
		else if ADoFire(Y, Vin,UsrInt_2) then UsrInt_2
		else if ADoFire(Y, Vin,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(Y_C, Vin_C,Vout_PD, Z_PD) = (UsrIntMult(AnbrFired, A_Y_rate_in),UsrIntMult(AnbrFired, A_Vin_rate_in),UsrIntMult(AnbrFired, A_Vout_rate_out),UsrIntMult(AnbrFired, A_Z_rate_out));

Vout_P = UsrInt_0 -> pre (UsrInt_0 -> pre (Vout_PD));

Z_P = UsrInt_0 -> pre (UsrInt_0 -> pre (Z_PD));


tel;
------------------
node ADoFire(Y, Vin,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(Y, UsrIntMult(times, A_Y_rate_in)) 
	and UsrIntGte(Vin, UsrIntMult(times, A_Vin_rate_in)) 
	then true 
	else false;

tel;
------------------
node A1(Z :UsrInt) returns (Z_C, B_P, B1_P, B2_P :UsrInt; A1nbrFired: UsrInt );

var
B_PD, B1_PD, B2_PD :UsrInt;
let
A1nbrFired= if A1DoFire(Z,UsrInt_3) then UsrInt_3
		else if A1DoFire(Z,UsrInt_2) then UsrInt_2
		else if A1DoFire(Z,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(Z_C,B_PD, B1_PD, B2_PD) = (UsrIntMult(A1nbrFired, A1_Z_rate_in),UsrIntMult(A1nbrFired, A1_B_rate_out),UsrIntMult(A1nbrFired, A1_B1_rate_out),UsrIntMult(A1nbrFired, A1_B2_rate_out));

B_P = UsrInt_0 -> pre (B_PD);

B1_P = UsrInt_0 -> pre (B1_PD);

B2_P = UsrInt_0 -> pre (B2_PD);


tel;
------------------
node A1DoFire(Z,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(Z, UsrIntMult(times, A1_Z_rate_in)) 
	then true 
	else false;

tel;
------------------
node P(X, B :UsrInt) returns (X_C, B_C :UsrInt; PnbrFired: UsrInt );

var 
temp: UsrInt;

let
temp= UsrInt_0-> pre (UsrInt_0 ->pre (UsrInt_0-> pre (UsrInt_0-> pre (UsrInt_0-> pre (X)))));
PnbrFired= if  PDoFire(temp, B,UsrInt_3) then UsrInt_3
		else if PDoFire(temp, B,UsrInt_2) then UsrInt_2
		else if PDoFire(temp, B,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(X_C, B_C) = (UsrIntMult(PnbrFired, P_X_rate_in), UsrIntMult(PnbrFired, P_B_rate_in) );

tel;
------------------
node PDoFire(X, B,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(X, UsrIntMult(times, P_X_rate_in)) 
	and UsrIntGte(B, UsrIntMult(times, P_B_rate_in)) 
	then true 
	else false;

tel;
------------------
node P2(B1, B2 :UsrInt) returns (B1_C, B2_C :UsrInt; P2nbrFired: UsrInt );

var
temp: UsrInt;

let
temp= UsrInt_0-> pre (UsrInt_0-> pre (UsrInt_0-> pre (B2)));
P2nbrFired= if  P2DoFire(temp, B2,UsrInt_3) then UsrInt_3
		else if P2DoFire(temp, B2,UsrInt_2) then UsrInt_2
		else if P2DoFire(temp, B2,UsrInt_1) then UsrInt_1
		else UsrInt_0;

(B1_C, B2_C) = (UsrIntMult(P2nbrFired, P2_B1_rate_in),UsrIntMult(P2nbrFired, P2_B2_rate_in));

tel;
------------------
node P2DoFire(B1, B2,times:UsrInt) returns ( yes: bool);
let

yes = if UsrIntGte(B1, UsrIntMult(times, P2_B1_rate_in)) 
	and UsrIntGte(B2, UsrIntMult(times, P2_B2_rate_in)) 
	then true 
	else false;

tel;
------------------

--**************** Node Top Declaration ****************--

node top (X_P, Y_P: UsrInt) returns (V, Z, B, B1, B2, X, Y, AnbrFired, A1nbrFired, PnbrFired, P2nbrFired:UsrInt);

-------------- Les variables -------------- 
var

V_C, V_P: UsrInt; 
Z_C, Z_P: UsrInt; 
B_C, B_P: UsrInt; 
B1_C, B1_P: UsrInt; 
B2_C, B2_P: UsrInt; 
X_C : UsrInt;
Y_C : UsrInt;

temp:bool;
XR , YR: UsrInt;

let

V = V_I -> pre UsrIntPlus( UsrIntMinus( V,V_C), V_P);
Z = Z_I -> pre UsrIntPlus( UsrIntMinus( Z,Z_C), Z_P);
B = B_I -> pre UsrIntPlus( UsrIntMinus( B,B_C), B_P);
B1 = B1_I -> pre UsrIntPlus( UsrIntMinus( B1,B1_C), B1_P);
B2 = B2_I -> pre UsrIntPlus( UsrIntMinus( B2,B2_C), B2_P);

temp= UsrIntLt (UsrIntPlus(UsrIntMinus(X ,X_C), X_P), maxValue) and UsrIntLt (UsrIntPlus(UsrIntMinus(Y ,Y_C), Y_P), maxValue) ;
 (XR, YR)= if temp then (UsrIntPlus( UsrIntMinus(X ,X_C), X_P), UsrIntPlus( UsrIntMinus(Y ,Y_C), Y_P)) else (UsrIntMinus( X,X_C), UsrIntMinus( Y,Y_C));

X = X_I-> pre XR ;
Y = Y_I -> pre YR;

(Y_C, V_C, V_P, Z_P, AnbrFired) = A(Y, V);
(Z_C, B_P, B1_P, B2_P, A1nbrFired) = A1(Z);
(X_C, B_C, PnbrFired) = P(X, B);
(B1_C, B2_C, P2nbrFired) = P2(B1, B2);


tel;
--**************** Node Harness Declaration ****************--

node Harness (X_P, Y_P: UsrInt) returns (noError :bool)

var

V, Z, B, B1, B2, X, Y, AnbrFired, A1nbrFired, PnbrFired, P2nbrFired:UsrInt;

positiveValues, P1, P2, P3: bool;

let

(V, Z, B, B1, B2, X, Y, AnbrFired, A1nbrFired, PnbrFired, P2nbrFired) = top(X_P, Y_P);

positiveValues = UsrIntGte( V, UsrInt_0) 
	and UsrIntGte( Z, UsrInt_0) 
	and UsrIntGte( B, UsrInt_0) 
	and UsrIntGte( B1, UsrInt_0) 
	and UsrIntGte( B2, UsrInt_0) 
	and UsrIntGte( X, UsrInt_0) 
	and UsrIntGte( Y, UsrInt_0) 
	and UsrIntGte( AnbrFired , UsrInt_0) 
	and UsrIntGte( A1nbrFired , UsrInt_0) 
	and UsrIntGte( PnbrFired , UsrInt_0) 
	and UsrIntGte( P2nbrFired , UsrInt_0) ;

--Proriété P1:
P1=  UsrIntLte(UsrIntMinus(B1, UsrInt_0-> pre (UsrInt_0-> pre (UsrInt_0-> pre (B2)))), V_I) ; 

--Proriété P2:
--P2=  UsrIntLte(B, TX_earlyTaTa1);  
P2= UsrIntLte(B,  UsrInt_0-> pre (UsrInt_0 ->pre (UsrInt_0-> pre (UsrInt_0-> pre (UsrInt_0-> pre (X))))) );


--Proriété P3: --true
--P3= (not UsrIntEq(B, pre B) )=> UsrIntEq(UsrIntMinus(B, B_earlyTa), V0) or  UsrIntEq(B, TX_earlyTaTa1);

-- P3 non encore bien ecrite!
P3=    ( UsrIntEq(UsrIntMinus(B1, UsrInt_0-> pre (UsrInt_0-> pre (UsrInt_0-> pre (B2)))), V_I) 
or UsrIntEq(B,  UsrInt_0-> pre (UsrInt_0 ->pre (UsrInt_0-> pre (UsrInt_0-> pre (UsrInt_0-> pre (X))))) ));


noError= positiveValues and P1 and P2;
 

assert UsrIntLte(X_P, UsrInt_1) and UsrIntGte(X_P, UsrInt_0) and UsrIntEq(X_P, Y_P);



tel;
