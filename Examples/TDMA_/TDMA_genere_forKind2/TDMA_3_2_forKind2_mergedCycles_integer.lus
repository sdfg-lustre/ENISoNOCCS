--** This lustre code is generated automatically. 
--** It corresponds to the translation of an SDFG model to Lustre. This version produce a Lustre code having a reduced number of steps.
--     29 mai 2020 11:56:49 PM




--**************** Const Rates ****************--

const A_e1_rate_in = 1;
const A_e3in_rate_in = 1;
const A_e3out_rate_out = 1;
const A_e4_rate_out = 1;
const A1_e4_rate_in = 1;
const A1_e2_rate_out = 1;

--****************  Actors' durations ****************--

const A_maxStages  = 3;
const A_duration  = 3;
const A1_maxStages  = 2;
const A1_duration  = 2;
const  maxDuration  = 3;

--**************** Init Channel ****************--

const e3_I = 3;
const e4_I = 0;

const e1_I = 0;
const e2_I = 0;

--************************************************--
--******* Translation of Actor: A***************--
--************************************************--
node A(clock, e1, e3in :int) returns (nextClock, e1_C, e3in_C, e3out_P, e4_P :int; AnbrFired: int );

var
e3out_PD, e4_PD :int;
stage :int;
 lastStage  :int;
rTime1, e3out_P1, e4_P1 : int; 
rTime2, e3out_P2, e4_P2 : int; 
rTime3, e3out_P3, e4_P3 : int; 
let
AnbrFired= if ADoFire(e1, e3in,3) then 3
		else if ADoFire(e1, e3in,2) then 2
		else if ADoFire(e1, e3in,1) then 1
		else 0;

(e1_C, e3in_C, e3out_PD, e4_PD) = ((AnbrFired * A_e1_rate_in),(AnbrFired * A_e3in_rate_in),(AnbrFired * A_e3out_rate_out),(AnbrFired * A_e4_rate_out));

stage = (if (AnbrFired = 0) then 0 
         else   1) 
 -> if (AnbrFired = 0) then 0 
         else if (pre lastStage = A_maxStages) then  1 
         else  (pre lastStage + 1) ; 
 
lastStage = (if (AnbrFired = 0) then 0 
         else   1) 
 -> if (AnbrFired = 0) then (pre lastStage) 
         else stage; 
 

(rTime1, e3out_P1, e4_P1)=AStage(clock, stage, 1, e3out_PD, e4_PD); 
(rTime2, e3out_P2, e4_P2)=AStage(clock, stage, 2, e3out_PD, e4_PD); 
(rTime3, e3out_P3, e4_P3)=AStage(clock, stage, 3, e3out_PD, e4_PD); 

 nextClock= Min(rTime1 , Min(rTime2 , rTime3));
 
e3out_P = (e3out_P1 + (e3out_P2 + e3out_P3));
e4_P = (e4_P1 + (e4_P2 + e4_P3));

tel;
------------------subnode Dofire of ActorA-----------------
node ADoFire(e1, e3in,times:int) returns ( yes: bool);
let

yes = if (e1>=  (times * A_e1_rate_in)) 
	and (e3in>=  (times * A_e3in_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of ActorA-----------------
node AStage(clock,  stage, numStage, e3out_PD, e4_PD: int) returns (rTime, e3out_P, e4_P : int);

var 
e3out_PDBuffer, e4_PDBuffer: int; 
selected, endExecution, active : bool; 

 let 
selected = if  (stage = numStage) then true else false ; 
 endExecution= false -> if not pre (active)  then false else pre  ((rTime - clock) = 0); 
active = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre active; 
rTime = if  selected then A_duration  else maxDuration -> 
          if  selected then A_duration 
          else if  (pre active) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 
(e3out_PDBuffer, e4_PDBuffer) = if selected then (e3out_PD, e4_PD) 
                               else (0, 0) 
 ->if selected then (e3out_PD, e4_PD) 
                               else if endExecution then (0, 0)
           else pre (e3out_PDBuffer, e4_PDBuffer); 
(e3out_P, e4_P) = (0, 0) ->   if endExecution then pre (e3out_PDBuffer, e4_PDBuffer)
                                        else (0, 0); 
tel; 


--************************************************--
--******* Translation of Actor: A1***************--
--************************************************--
node A1(clock, e4 :int) returns (nextClock, e4_C, e2_P :int; A1nbrFired: int );

var
e2_PD :int;
stage :int;
 lastStage  :int;
rTime1, e2_P1 : int; 
rTime2, e2_P2 : int; 
let
A1nbrFired= if A1DoFire(e4,3) then 3
		else if A1DoFire(e4,2) then 2
		else if A1DoFire(e4,1) then 1
		else 0;

(e4_C, e2_PD) = ((A1nbrFired * A1_e4_rate_in),(A1nbrFired * A1_e2_rate_out));

stage = (if (A1nbrFired = 0) then 0 
         else   1) 
 -> if (A1nbrFired = 0) then 0 
         else if (pre lastStage = A1_maxStages) then  1 
         else  (pre lastStage + 1) ; 
 
lastStage = (if (A1nbrFired = 0) then 0 
         else   1) 
 -> if (A1nbrFired = 0) then (pre lastStage) 
         else stage; 
 

(rTime1, e2_P1)=A1Stage(clock, stage, 1, e2_PD); 
(rTime2, e2_P2)=A1Stage(clock, stage, 2, e2_PD); 

 nextClock= Min(rTime1 , rTime2);
 
e2_P = (e2_P1 + e2_P2);

tel;
------------------subnode Dofire of ActorA1-----------------
node A1DoFire(e4,times:int) returns ( yes: bool);
let

yes = if (e4>=  (times * A1_e4_rate_in)) 
	then true 
	else false;

tel;
------------------subnode Stage of ActorA1-----------------
node A1Stage(clock,  stage, numStage, e2_PD: int) returns (rTime, e2_P : int);

var 
e2_PDBuffer: int; 
selected, endExecution, active : bool; 

 let 
selected = if  (stage = numStage) then true else false ; 
 endExecution= false -> if not pre (active)  then false else pre  ((rTime - clock) = 0); 
active = if  selected then true else false -> 
           if  selected then true 
         else if  endExecution then false else pre active; 
rTime = if  selected then A1_duration  else maxDuration -> 
          if  selected then A1_duration 
          else if  (pre active) then if  (pre (rTime > clock) )then  pre (rTime - clock) 
          else maxDuration   else maxDuration ; 
(e2_PDBuffer) = if selected then (e2_PD) 
                               else (0) 
 ->if selected then (e2_PD) 
                               else if endExecution then (0)
           else pre (e2_PDBuffer); 
(e2_P) = (0) ->   if endExecution then pre (e2_PDBuffer)
                                        else (0); 
tel; 

--******* Node Min***************--
node Min (x, y :int) returns ( r: int);
let
r= if  (x < y) then x else y;
tel;

--************************************************--
--******* Node Top***************--
--************************************************--
node top (e1_P: int) returns ( clock, e3, e4, e1, e2, AnbrFired, A1nbrFired:int);

var

e3_C, e3_P: int; 
e4_C, e4_P: int; 
e1_C : int;
e2_P : int;
AnextClock : int;  
A1nextClock : int;  
positiveValues: bool; 

let


 
e3 = e3_I ->  ( pre ( e3 - e3_C) + e3_P);
e4 = e4_I ->  ( pre ( e4 - e4_C) + e4_P);


e1 = e1_P -> pre  ( e1-e1_C)+ e1_P ;

e2 = e2_I -> pre (e2+ e2_P);

(AnextClock, e1_C, e3_C, e3_P, e4_P, AnbrFired) = A(clock, e1, e3);
(A1nextClock, e4_C, e2_P, A1nbrFired) = A1(clock, e4);

clock= 0-> Min(AnextClock , A1nextClock);



positiveValues = ( e3 >= 0) 
	and ( e4 >= 0) 
	and ( e1 >= 0) 
	and ( e2>= 0) 
	and ( AnbrFired  >=  0) 
	and ( A1nbrFired  >=  0) ;

assert e1_P  >=0; 
--%MAIN;

--%PROPERTY  "Ok, all variables are positive "  positiveValues;


tel;


